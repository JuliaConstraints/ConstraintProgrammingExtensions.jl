var documenterSearchIndex = {"docs":
[{"location":"mappings/yalmip/#Yalmip","page":"Yalmip","title":"Yalmip","text":"","category":"section"},{"location":"mappings/yalmip/","page":"Yalmip","title":"Yalmip","text":"Only CP constraints in Yalmip: ","category":"page"},{"location":"mappings/yalmip/","page":"Yalmip","title":"Yalmip","text":"alldifferent: mapped to MILP constraints\niff\nimplies","category":"page"},{"location":"mappings/constraintsolver/#ConstraintSolver.jl","page":"ConstraintSolver.jl","title":"ConstraintSolver.jl","text":"","category":"section"},{"location":"mappings/constraintsolver/","page":"ConstraintSolver.jl","title":"ConstraintSolver.jl","text":"All the constraints that are currently supported by ConstraintSolver.jl, up-to-date with v0.6.5: ","category":"page"},{"location":"mappings/constraintsolver/","page":"ConstraintSolver.jl","title":"ConstraintSolver.jl","text":"AllDifferentSet: AllDifferent\nTableSet: VectorDomain\nNotEqualTo: DifferentFrom\nStrictly: Strictly\nReifiedSet: Reification\nBoolSet: Conjunction, Disjunction, Negation","category":"page"},{"location":"mappings/hakank/#Hakank","page":"Hakank","title":"Hakank","text":"","category":"section"},{"location":"mappings/hakank/","page":"Hakank","title":"Hakank","text":"All the constraints that are currently defined in hakank's constraints_utils.jl: ","category":"page"},{"location":"mappings/hakank/","page":"Hakank","title":"Hakank","text":"increasing: Increasing\ndecreasing: Decreasing\nincreasing_strict: Strictly(Increasing)\ndecreasing_strict: Strictly(Decreasing)\nall_different_except_c: AllDifferentExceptConstants\ncount_ctr: Count (except for operators)\ncount_ctr2: CountDistinct (except for operators)\nglobal_cardinality_count: Count\neither_eq: Disjunction\nis_member_of: Domain and Membership\ncumulative: CumulativeResource and CumulativeResourceWithDeadline\ncircuit: Circuit and WeightedCircuit\ncircuit_path: CircuitPath and WeightedCircuitPath\ninverse: Inverse\nassignment: Inverse\nassignment_ctr: not yet\nmatrix_element: Element, but to generalise to more than one dimension\nregular: not yet (no representation of finite automata in Julia)\natmost: Count with LessThan\natleast: Count with GreaterThan\nexactly: Count\nlatin_square: AllDifferent\nno_overlap: not yet (no representation of intervals)\nglobal_contiguity_regular: Contiguity\nlex_less_eq: LexicographicallyLessThan\namong: Count","category":"page"},{"location":"mappings/hakank/","page":"Hakank","title":"Hakank","text":"Functions: TODO","category":"page"},{"location":"mappings/numberjack/#Numberjack","page":"Numberjack","title":"Numberjack","text":"","category":"section"},{"location":"mappings/numberjack/","page":"Numberjack","title":"Numberjack","text":"Numberjack has a very similar goal to this project: a common modelling interface for many underlying solvers. List of supported global constraints: https://github.com/eomahony/Numberjack/blob/master/doc/source/globalcons.rst. List of other constraints: https://github.com/eomahony/Numberjack/blob/master/doc/source/constraints.rst","category":"page"},{"location":"mappings/numberjack/","page":"Numberjack","title":"Numberjack","text":"Numberjack.AllDiff: AllDifferent\nNumberjack.AllDiffExcept0: AllDifferentExceptConstants\nNumberjack.Sum: MOI (linear expressions\nNumberjack.Product: MOI (quadratic expressions)\nNumberjack.Gcc: Count\nNumberjack.LessLex: LexicographicallyLessThan\nNumberjack.LeqLex: LexicographicallyLessThan\nNumberjack.Disjunction: Disjunction\nNumberjack.Conjunction: Conjunction\nNumberjack.Max: MaximumAmong\nNumberjack.Min: MinimumAmong\nNumberjack.Element: Element\nNumberjack.Cardinality: Count\nNumberjack.Neg: MOI (-)\nNumberjack.Abs: AbsoluteValue\nNumberjack.And: Conjunction\nNumberjack.Or: Disjunction\nNumberjack.Eq: MOI.EqualTo\nNumberjack.Ne: DifferentFrom\nNumberjack.Lt: MOI.LessThan and Strictly\nNumberjack.Le: MOI.LessThan\nNumberjack.Gt: MOI.GreaterThan and Strictly\nNumberjack.Ge: MOI.GreaterThan\nNumberjack.Mul: MOI (quadratic expression)\nNumberjack.Div: MOI (quadratic expression)\nNumberjack.Mod: not yet (function)\nNumberjack.Table: Domain\nNumberjack.Precedence: not yet (no notion of interval)\nNumberjack.NoOverlap: not yet (no notion of interval)\nNumberjack.UnaryResource: CumulativeResource","category":"page"},{"location":"mappings/disjunctive/#DisjunctiveConstraints.jl","page":"DisjunctiveConstraints.jl","title":"DisjunctiveConstraints.jl","text":"","category":"section"},{"location":"mappings/disjunctive/","page":"DisjunctiveConstraints.jl","title":"DisjunctiveConstraints.jl","text":"DisjunctiveConstraints  focuses on disjunctions, but only with linear constraints: their  DisjunctiveSet corresponds to Disjunction of linear constraints Interval.","category":"page"},{"location":"mappings/sas/#SAS","page":"SAS","title":"SAS","text":"","category":"section"},{"location":"mappings/sas/","page":"SAS","title":"SAS","text":"Based on the current docs, SAS' constraint-programming interface is still burgeoning: ","category":"page"},{"location":"mappings/sas/","page":"SAS","title":"SAS","text":"ALLDIFF: CP.AllDifferent\nCUMULATIVE: CP.CumulativeResource\nELEMENT\nGCC\nLEXICO\nPACK: CP.BinPacking and variants\nREIFY: CP.Reify","category":"page"},{"location":"mappings/sas/","page":"SAS","title":"SAS","text":"There are more features in the scheduling module:","category":"page"},{"location":"mappings/sas/","page":"SAS","title":"SAS","text":"ACTIVITY: TODO\nALLDIFF: CP.AllDifferent\nCUMULATIVE: CP.CumulativeResource\nARRAY\nELEMENT\nFOREACH\nGCC\nLEXICO\nLINCON: standard MOI\nOBJ: standard MOI\nPACK: CP.BinPacking and variants\nREIFY: CP.Reify\nREQUIRES\nRESOURCE\nSCHEDULE\nVARIABLE","category":"page"},{"location":"mappings/juliaconstraints/#JuliaConstraints","page":"JuliaConstraints","title":"JuliaConstraints","text":"","category":"section"},{"location":"mappings/juliaconstraints/","page":"JuliaConstraints","title":"JuliaConstraints","text":"All the constraints of the JuliaConstraints ecosystem are supported, with the exception of always_true: ","category":"page"},{"location":"mappings/juliaconstraints/","page":"JuliaConstraints","title":"JuliaConstraints","text":"all_different: AllDifferent set\nall_equal: either a set of equalities or MaximumDistance\nall_equal_param: a set of equalities to the constant\nalways_true: True set\ndist_different: DifferentFrom set\neq: standard MOI.EqualTo\nordered: Sort set","category":"page"},{"location":"mappings/juliaconstraints/","page":"JuliaConstraints","title":"JuliaConstraints","text":"(Order from Constraints.jl.)","category":"page"},{"location":"mappings/minizinc/#MiniZinc","page":"MiniZinc","title":"MiniZinc","text":"","category":"section"},{"location":"mappings/minizinc/","page":"MiniZinc","title":"MiniZinc","text":"MiniZinc has a similar goal to this project: a common modelling interface for many underlying solvers. It is based on a similar concept to that of bridges, but with much less flexibility: each high-level constraint is mapped in a fixed way onto lower-level constraints.","category":"page"},{"location":"mappings/minizinc/","page":"MiniZinc","title":"MiniZinc","text":"Basic CP constraints: \nDomain: \nFixed: CP.Domain\nVariable: CP.Membership\nMultivalued: CP.VectorDomain\ntable: one binary variable per possible combination\nAll different: \nBase: CP.AllDifferent\nall_different: mapped onto a MILP-like model.\nall_different_reif: similar, with an equivalence.\nThese constraints are available in two includes: all_different.mzn and alldifferent.mzn. \nAll different except constants: CP.AllDifferentExceptConstants\nalldifferent_except_0 (one excluded value: 0) and alldifferent_except (set of excluded values): either mapped onto neq and disjunctions or onto GCC. \nalldifferent_except_0_reif (one excluded value: 0) and alldifferent_except_reif (set of excluded values): the reified versions are only mapped onto neq and disjunctions.\nWith symmetry: SymmetricAllDifferent\nsymmetric_all_different: all_different and inverse\nsymmetric_all_different: similar, with an equivalence\nAll equal: CP.AllEqual\nall_equal: mapped onto a series of equalities if the dimension is at least two.\nall_equal_reif: similar, with an equivalence.\nCounting: CP.Count; variants of Minizinc's count are not equivalent to the parameters of CP.Count, Minizinc only matches CP.Count{MOI.EqualTo}\ncount_eq: direct comparison of each element.\ncount_eq_reif: similar, with an equivalence.\ncount_neq, count_lt, count_le, count_gt, count_ge: count_eq with a !=, <, <=, >, >= constraint.\ncount_neq_reif, count_lt_reif, count_le_reif, count_gt_reif, count_ge_reif: similar, with an equivalence.\nexactly: simple variation of count, not directly mapped in this package.\nglobal_cardinality: simple variation of count.\nglobal_cardinality_fn: function, simple variation of count.\nglobal_cardinality_closed: simple variation of count with domains.\nglobal_cardinality_closed_fn: function, simple variation of count.\nnvalue: simple variation of reified comparisons.\nnvalue_reif: similar, with an equivalence.\nnvalue_fn: function.\nInversion: CP.Inverse\ninverse: index computations.\ninverse_reif: similar, wih an equivalence.\nAlso available as a function.\ninverse_in_range: ?.\nSliding sum: CP.SlidingSum\nsliding_sum: quite complex mapping.\nsliding_sum_reif: similar, with an equivalence.\nPrecedence: CP.ValuePrecedence\nvalue_precede: [several reifications)(https://github.com/MiniZinc/libminizinc/blob/master/share/minizinc/std/fznvalueprecede_int.mzn).\n[No reified variant)(https://github.com/MiniZinc/libminizinc/blob/master/share/minizinc/std/fznvalueprecedeintreif.mzn).\nCombinatorial sets:\nBin packing: \nRaw: CP.BinPacking (with supplementary load variables)\nbin_packing: mapped onto a MILP-like model, but without binary variables (replaced by their definition in the capacity constraint: bin[item] == value). \nbin_packing_reif: similar, with an equivalence.\nCapacitated: CP.FixedCapacityBinPacking and CP.VariableCapacityBinPacking (with supplementary load variables)\nbin_packing_capa: same MILP-like model with a linear capacity constraint.\nbin_packing_capa_reif: similar, with an equivalence.\nLoad: CP.BinPacking\nbin_packing_load: similar MILP-like model.\nbin_packing_load_reif: similar MILP-like model.\nFunction: CP.BinPacking and CP.BinPackingLoadFunction\nbin_packing_load_fn directly returns the load variables.\nKnapsack: CP.Knapsack with values\nknapsack: mapped onto a MILP model.\nknapsack_reif: similar, with an equivalence.\nSorting: \nMaximum/minimum: CP.MaximumAmong and CP.MinimumAmong\nmaximum: built-in, except for linear solvers\nminimum: built-in, except for linear solvers\nNo reification available.\nArgument maximum/minimum: CP.ArgumentMaximumAmong and CP.MinimumAmong\narg_max: complex mapping from The ARGMAX Constraint, CP2020.\narg_min: complex mapping from The ARGMAX Constraint, CP2020.\nNo reification available.\nPermutation to sort: CP.SortPermutation\narg_sort: alldifferent and array indexing.\nNo reification available.\nSort: CP.Sort\nsort: alldifferent, increasing and array indexing, highly similar to arg_sort.\nsort_reif: equivalence, indicating whether a given array is a sorted copy of another.\nsort_fn: returns the sorted array, based on sort.\nIncreasing and decreasing: CP.Increasing, CP.Decreasing, and CP.Strictly\nincreasing: sequence of inequalities.\ndecreasing: sequence of inequalities.\nstrictly_increasing: sequence of strict inequalities.\nstrictly_decreasing: sequence of strict inequalities.\nNo reification available.\nLexicographic sorting: CP.LexicographicallyLessThan, CP.LexicographicallyGreaterThan, CP.DoublyLexicographicallyLessThan, and CP.DoublyLexicographicallyGreaterThan\nlex_greater, lex_less, lex_greatereq, lex_lesseq: implemented using the definition of lexicographic sorting.\nlex_chain_greater, lex_chain_less, lex_chain_greatereq, lex_chain_lesseq: lexicographic sort of a matrix of vectors, mapped to lexicographic relation between two arrays.\nlex2: in a matrix, have both rows and columns lexicographically sorted, mapped to two chains.\nstrict_lex2: in a matrix, have both rows and columns strictly lexicographically sorted, mapped to two chains.\nReifications are available.\nScheduling: \nRectangle overlapping: CP.NonOverlappingOrthotopes\ndiffn: mapped to a disjunction of linear inequalities.\ndiffn_k: generalisation to k dimensions.\nNo reification available, but a similar mapping is available.","category":"page"},{"location":"reference/bridges_sets/","page":"Set bridges","title":"Set bridges","text":"CurrentModule = ConstraintProgrammingExtensions.Bridges","category":"page"},{"location":"reference/bridges_sets/#Set-bridges","page":"Set bridges","title":"Set bridges","text":"","category":"section"},{"location":"reference/bridges_sets/","page":"Set bridges","title":"Set bridges","text":"add_all_set_bridges\nAbsoluteValue2MILPBridge\nAllDifferent2DifferentFromBridge\nAllDifferentExceptConstants2ConjunctionDisjunctionBridge\nAllDifferentExceptConstants2ReificationBridge\nAllEqual2EqualToBridge\nArgumentMaximumAmong2MILPBridge\nArgumentMinimumAmong2MILPBridge\nBinPacking2MILPBridge\nFixedCapacityBinPacking2BinPackingBridge\nFixedCapacityBinPacking2VariableCapacityBinPackingBridge\nVariableCapacityBinPacking2BinPackingBridge\nGlobalCardinalityFixedClosed2GlobalCardinalityFixedOpenBridge\nGlobalCardinalityVariableClosed2GlobalCardinalityVariableOpenBridge\nConjunction2ReificationBridge\nCount2ReificationBridge\nCountCompare2CountBridge\nDecreasing2LPBridge\nDifferentFrom2PseudoMILPBridge\nIndicatorDifferentFrom2PseudoMILPBridge\nReificationDifferentFrom2IndicatorBridge\nReificationDifferentFrom2MILPBridge\nDisjunction2ReificationBridge\nDomain2MILPBridge\nDoublyLexicographicallyLessThan2LexicographicallyLessThanBridge\nDoublyLexicographicallyGreaterThan2LexicographicallyGreaterThanBridge\nElement2MILPBridge\nElementVariableArray2MILPBridge\nReificationEqualTo2IndicatorBridge\nReificationEqualTo2MILPBridge\nReificationGreaterThan2IndicatorBridge\nReificationGreaterThan2MILPBridge\nGlobalCardinalityFixedOpen2CountBridge\nGlobalCardinalityFixedOpen2GlobalCardinalityVariableOpenBridge\nGlobalCardinalityVariableOpen2CountBridge\nIfThenElse2ImplicationBridge\nIfThenElse2ReificationBridge\nImplication2ReificationBridge\nIncreasing2LPBridge\nInverse2ReificationBridge\nKnapsack2MILPBridge\nKnapsack2VariableCapacityKnapsackBridge\nValuedKnapsack2KnapsackBridge\nVariableCapacityValuedKnapsack2VariableCapacityKnapsackBridge\nReificationLessThan2IndicatorBridge\nReificationLessThan2MILPBridge\nLexicographicallyGreaterThan2IndicatorBridge\nLexicographicallyLessThan2IndicatorBridge\nStrictlyDecreasing2LPBridge\nDoublyStrictlyLexicographicallyLessThan2StrictlyLexicographicallyGreaterThanBridge\nDoublyStrictlyLexicographicallyLessThan2StrictlyLexicographicallyLessThanBridge\nStrictlyIncreasing2LPBridge\nStrictlyLexicographicallyGreaterThan2IndicatorBridge\nStrictlyLexicographicallyLessThan2IndicatorBridge\nStrictly2LPBridge\nMaximumAmong2MILPBridge\nMinimumAmong2MILPBridge\nNonOverlappingOrthotopes2DisjunctionLPBridge\nNonOverlappingOrthotopes2ConditionallyNonOverlappingOrthotopesBridge\nSort2MILPBridge\nSort2SortPermutationBridge\nSortPermutation2AllDifferentBridge\nSlidingSum2LPBridge\nSymmetricAllDifferent2AllDifferentInverseBridge\nValuePrecedence2ReificationBridge\nVectorDomain2MILPBridge","category":"page"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.add_all_set_bridges","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.add_all_set_bridges","text":"add_all_set_bridges(bridged_model, ::Type{T}) where {T}\n\nAdd all set bridges defined in the Bridges submodule to bridged_model.  The coefficient type used is T.\n\n\n\n\n\n","category":"function"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.AbsoluteValue2MILPBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.AbsoluteValue2MILPBridge","text":"Bridges CP.AbsoluteValue to linear constraints and integer constraints.\n\nThe implemented model is the most generic one, so that the absolute value  always has a well-defined value. This requires the use of a binary variable. In many cases, this is not necessary, and simpler models could be used, but  checking this automatically would require access to the whole model.\n\nBased on Mosek's  modelling cookbook.\n\nYALMIP implements a similar formulation, with big-M and small-m values  computed based on the bounds for each variable.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.AllDifferent2DifferentFromBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.AllDifferent2DifferentFromBridge","text":"Bridges CP.AllDifferent to a series of CP.DifferentFrom.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.AllDifferentExceptConstants2ConjunctionDisjunctionBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.AllDifferentExceptConstants2ConjunctionDisjunctionBridge","text":"Bridges CP.AllDifferentExceptConstants to a series of CP.Disjunction of CP.DifferentFrom and CP.Domain.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.AllDifferentExceptConstants2ReificationBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.AllDifferentExceptConstants2ReificationBridge","text":"Bridges CP.AllDifferentExceptConstants to reifications.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.AllEqual2EqualToBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.AllEqual2EqualToBridge","text":"Bridges CP.AllEqual to a series of CP.EqualTo.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.ArgumentMaximumAmong2MILPBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.ArgumentMaximumAmong2MILPBridge","text":"Bridges CP.ArgumentMaximumAmong to MILP formulations, by the means of big-M  constraints.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.ArgumentMinimumAmong2MILPBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.ArgumentMinimumAmong2MILPBridge","text":"Bridges CP.ArgumentMinimumAmong to MILP formulations, by the means of big-M  constraints.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.BinPacking2MILPBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.BinPacking2MILPBridge","text":"Bridges CP.BinPacking to a MILP by creating binary variables for the bin  assignment and MILP constraints.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.FixedCapacityBinPacking2BinPackingBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.FixedCapacityBinPacking2BinPackingBridge","text":"Bridges CP.BinPacking{CP.FIXED_CAPACITY_BINPACKING} to CP.BinPacking{CP.NO_CAPACITY_BINPACKING} by adding constraints  on the capacity variables.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.FixedCapacityBinPacking2VariableCapacityBinPackingBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.FixedCapacityBinPacking2VariableCapacityBinPackingBridge","text":"Bridges CP.BinPacking{CP.FIXED_CAPACITY_BINPACKING, T} to  CP.BinPacking{CP.VARIABLE_CAPACITY_BINPACKING, T} by creating capacity  variables.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.VariableCapacityBinPacking2BinPackingBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.VariableCapacityBinPacking2BinPackingBridge","text":"Bridges CP.BinPacking{CP.VARIABLE_CAPACITY_BINPACKING, T} to  CP.BinPacking{CP.NO_CAPACITY_BINPACKING, T} by adding constraints on the  capacity variables.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.GlobalCardinalityFixedClosed2GlobalCardinalityFixedOpenBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.GlobalCardinalityFixedClosed2GlobalCardinalityFixedOpenBridge","text":"Bridges CP.GlobalCardinality{CP.FIXED_COUNTED_VALUES, CP.CLOSED_COUNTED_VALUES, T} to CP.GlobalCardinality{CP.FIXED_COUNTED_VALUES, CP.OPEN_COUNTED_VALUES, T.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.GlobalCardinalityVariableClosed2GlobalCardinalityVariableOpenBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.GlobalCardinalityVariableClosed2GlobalCardinalityVariableOpenBridge","text":"Bridges  GlobalCardinality{CP.VARIABLE_COUNTED_VALUES, CP.CLOSED_COUNTED_VALUES, T} to GlobalCardinality{CP.VARIABLE_COUNTED_VALUES, CP.OPEN_COUNTED_VALUES, T}.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.Conjunction2ReificationBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.Conjunction2ReificationBridge","text":"Bridges CP.Conjunction to reification.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.Count2ReificationBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.Count2ReificationBridge","text":"Bridges CP.Count to reification.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.CountCompare2CountBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.CountCompare2CountBridge","text":"Bridges CP.CountCompare to CP.Count.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.Decreasing2LPBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.Decreasing2LPBridge","text":"Bridges CP.Decreasing to linear constraints.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.DifferentFrom2PseudoMILPBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.DifferentFrom2PseudoMILPBridge","text":"Bridges CP.DifferentFrom to linear constraints (including, possibly, strict  inequalities). This constraint adds one variable to store the absolute value of the difference, and constrains it to be nonzero.\n\nFor AbstractFloat arguments (like Float64): equivalent to abs(x) > 0.0, i.e. a Strictly(GreaterThan(0.0)).\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.IndicatorDifferentFrom2PseudoMILPBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.IndicatorDifferentFrom2PseudoMILPBridge","text":"Bridges MOI.Indicator{A, CP.DifferentFrom} to linear constraints  (including, possibly, strict inequalities). This constraint adds one variable to store the absolute value of the difference, and uses it for the indicator.\n\nFor AbstractFloat arguments (like Float64): equivalent to abs(x) > 0.0, i.e. a Strictly(GreaterThan(0.0)).\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.ReificationDifferentFrom2IndicatorBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.ReificationDifferentFrom2IndicatorBridge","text":"Bridges CP.Reification{CP.DifferentFrom} to indicator constraints, both with equality and inequalities (CP.DifferentFrom).\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.ReificationDifferentFrom2MILPBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.ReificationDifferentFrom2MILPBridge","text":"Bridges CP.Reification{CP.DifferentFrom} to MILP constraints.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.Disjunction2ReificationBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.Disjunction2ReificationBridge","text":"Bridges CP.Disjunction to reification.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.Domain2MILPBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.Domain2MILPBridge","text":"Bridges CP.Domain to MILP by adding one binary variable per possible  combination.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.DoublyLexicographicallyLessThan2LexicographicallyLessThanBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.DoublyLexicographicallyLessThan2LexicographicallyLessThanBridge","text":"Bridges CP.DoublyLexicographicallyLessThan to CP.LexicographicallyLessThan.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.DoublyLexicographicallyGreaterThan2LexicographicallyGreaterThanBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.DoublyLexicographicallyGreaterThan2LexicographicallyGreaterThanBridge","text":"Bridges CP.DoublyLexicographicallyGreaterThan to CP.LexicographicallyGreaterThan.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.Element2MILPBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.Element2MILPBridge","text":"Bridges CP.Element to MILP constraints by using a unary encoding of the  index in the array.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.ElementVariableArray2MILPBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.ElementVariableArray2MILPBridge","text":"Bridges CP.ElementVariableArray to MILP constraints by using a unary  encoding of the index in the array.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.ReificationEqualTo2IndicatorBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.ReificationEqualTo2IndicatorBridge","text":"Bridges CP.Reification{MOI.EqualTo} to indicator constraints, both with equality and inequalities (CP.DifferentFrom).\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.ReificationEqualTo2MILPBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.ReificationEqualTo2MILPBridge","text":"Bridges CP.Reification{MOI.EqualTo} to MILP constraints.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.ReificationGreaterThan2IndicatorBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.ReificationGreaterThan2IndicatorBridge","text":"Bridges CP.Reification{MOI.GreaterThan} to indicator constraints with (strict)  inequalities.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.ReificationGreaterThan2MILPBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.ReificationGreaterThan2MILPBridge","text":"Bridges CP.Reification{MOI.GreaterThan} to MILP constraints.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.GlobalCardinalityFixedOpen2CountBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.GlobalCardinalityFixedOpen2CountBridge","text":"Bridges CP.GlobalCardinality to CP.Count.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.GlobalCardinalityFixedOpen2GlobalCardinalityVariableOpenBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.GlobalCardinalityFixedOpen2GlobalCardinalityVariableOpenBridge","text":"Bridges CP.GlobalCardinality to CP.GlobalCardinalityVariable.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.GlobalCardinalityVariableOpen2CountBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.GlobalCardinalityVariableOpen2CountBridge","text":"Bridges CP.GlobalCardinality{CP.VARIABLE_COUNTED_VALUES, CP.OPEN_COUNTED_VALUES, T} to CP.Count.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.IfThenElse2ImplicationBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.IfThenElse2ImplicationBridge","text":"Bridges CP.IfThenElse to CP.Implication.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.IfThenElse2ReificationBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.IfThenElse2ReificationBridge","text":"Bridges CP.IfThenElse to reification.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.Implication2ReificationBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.Implication2ReificationBridge","text":"Bridges CP.Implication to reification.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.Increasing2LPBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.Increasing2LPBridge","text":"Bridges CP.Increasing to linear constraints.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.Inverse2ReificationBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.Inverse2ReificationBridge","text":"Bridges CP.Inverse to reification.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.Knapsack2MILPBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.Knapsack2MILPBridge","text":"Bridges CP.Knapsack{KCT, KVT} to a MILP by adding the corresponding MILP  constraint.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.Knapsack2VariableCapacityKnapsackBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.Knapsack2VariableCapacityKnapsackBridge","text":"Bridges  CP.Knapsack{CP.FIXED_CAPACITY_KNAPSACK, CP.UNVALUED_KNAPSACK}  to CP.Knapsack{CP.VARIABLE_CAPACITY_KNAPSACK, CP.UNVALUED_KNAPSACK} by creating  capacity variables.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.ValuedKnapsack2KnapsackBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.ValuedKnapsack2KnapsackBridge","text":"Bridges  CP.Knapsack{CP.FIXED_CAPACITY_KNAPSACK, CP.VALUED_KNAPSACK, T} to  CP.Knapsack{CP.FIXED_CAPACITY_KNAPSACK, CP.UNVALUED_KNAPSACK, T}  by creating a value constraint.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.VariableCapacityValuedKnapsack2VariableCapacityKnapsackBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.VariableCapacityValuedKnapsack2VariableCapacityKnapsackBridge","text":"Bridges  CP.Knapsack{CP.VARIABLE_CAPACITY_KNAPSACK, CP.VALUED_KNAPSACK, } to  CP.Knapsack{CP.VARIABLE_CAPACITY_KNAPSACK, CP.UNVALUED_KNAPSACK, T}  by creating a value constraint.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.ReificationLessThan2IndicatorBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.ReificationLessThan2IndicatorBridge","text":"Bridges CP.Reification{MOI.LessThan} to indicator constraints with (strict)  inequalities.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.ReificationLessThan2MILPBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.ReificationLessThan2MILPBridge","text":"Bridges CP.Reification{MOI.LessThan} to MILP constraints.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.LexicographicallyGreaterThan2IndicatorBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.LexicographicallyGreaterThan2IndicatorBridge","text":"Bridges CP.LexicographicallyGreaterThan to indicators.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.LexicographicallyLessThan2IndicatorBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.LexicographicallyLessThan2IndicatorBridge","text":"Bridges CP.LexicographicallyLessThan to indicators.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.StrictlyDecreasing2LPBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.StrictlyDecreasing2LPBridge","text":"Bridges CP.Strictly{CP.Decreasing} to linear constraints.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.DoublyStrictlyLexicographicallyLessThan2StrictlyLexicographicallyGreaterThanBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.DoublyStrictlyLexicographicallyLessThan2StrictlyLexicographicallyGreaterThanBridge","text":"Bridges CP.Strictly{CP.DoublyLexicographicallyGreaterThan}  to CP.Strictly{CP.LexicographicallyGreaterThan}.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.DoublyStrictlyLexicographicallyLessThan2StrictlyLexicographicallyLessThanBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.DoublyStrictlyLexicographicallyLessThan2StrictlyLexicographicallyLessThanBridge","text":"Bridges CP.Strictly{CP.DoublyLexicographicallyLessThan} to  CP.Strictly{CP.LexicographicallyLessThan}.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.StrictlyIncreasing2LPBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.StrictlyIncreasing2LPBridge","text":"Bridges CP.Strictly{CP.Increasing} to linear constraints.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.StrictlyLexicographicallyGreaterThan2IndicatorBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.StrictlyLexicographicallyGreaterThan2IndicatorBridge","text":"Bridges CP.Strictly{CP.LexicographicallyGreaterThan} to indicators.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.StrictlyLexicographicallyLessThan2IndicatorBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.StrictlyLexicographicallyLessThan2IndicatorBridge","text":"Bridges CP.Strictly{CP.LexicographicallyLessThan} to indicators.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.Strictly2LPBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.Strictly2LPBridge","text":"Bridges CP.Strictly to linear constraints.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.MaximumAmong2MILPBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.MaximumAmong2MILPBridge","text":"Bridges CP.MaximumAmong to MILP formulations, by the means of big-M  constraints.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.MinimumAmong2MILPBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.MinimumAmong2MILPBridge","text":"Bridges CP.MinimumAmong to MILP formulations, by the means of big-M  constraints.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.NonOverlappingOrthotopes2DisjunctionLPBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.NonOverlappingOrthotopes2DisjunctionLPBridge","text":"Bridges CP.NonOverlappingOrthotopes to CP.Disjunction of linear  inequations (MOI.LessThan{T}).\n\nVariable number of constraints in the disjunction (two per dimension).\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.NonOverlappingOrthotopes2ConditionallyNonOverlappingOrthotopesBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.NonOverlappingOrthotopes2ConditionallyNonOverlappingOrthotopesBridge","text":"Bridges CP.NonOverlappingOrthotopes{CP.UNCONDITIONAL_NONVERLAPPING_ORTHOTOPES} to  CP.NonOverlappingOrthotopes{CP.CONDITIONAL_NONVERLAPPING_ORTHOTOPES}.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.Sort2MILPBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.Sort2MILPBridge","text":"Bridges CP.Sort to MILP constraints by adding O(n²) binary variables, with a  transportation-like model.\n\nDetailed model\n\nLet x be the array to sort and y its sorted copy, both vectors having  length n. This bridge handles the constraint [y..., x...]-in-CP.Sort(n).\n\nTwo sets of variables: \n\nf[i, j]: real variable, i from 1 to n; the \"flow\" from the array to  sort to the sorted copy, equal to the value of x[i] and y[j]\na[i, j]: binary variable, i from 1 to n; a[i, j] indicates whether  the flow f[i, j] is nonzero\n\nConstraints: \n\nFlow coming from the array to sort x:    x_i = sum_j=1^n f_ij qquad forall i in 1 2dots n\nFlow going to the sorted array:    y_j = sum_i=1^n f_ij qquad forall j in 1 2dots n\nThe flow from one value of the array to sort can only go to one element of  the sorted array:   sum_i=1^n a_ij = 1 qquad forall j in 1 2dots n\nThe flow to one value of the sorted array can only come from one element of  the array to sort:   sum_j=1^n a_ij = 1 qquad forall i in 1 2dots n\nThe flow f[i, j] is related to the binary variable a[i, j]:    U a_ij leq f_ij leq L a_ij qquad forall (ij) in 1 2dots n^2\nThe array y must be sorted:   y_j-1 leq y_j qquad forall j in 2 3dots n\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.Sort2SortPermutationBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.Sort2SortPermutationBridge","text":"Bridges CP.Sort to CP.SortPermutation by adding index variables.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.SortPermutation2AllDifferentBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.SortPermutation2AllDifferentBridge","text":"Bridges CP.SortPermutation to CP.AllDifferent and  CP.ElementVariableArray.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.SlidingSum2LPBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.SlidingSum2LPBridge","text":"Bridges CP.SlidingSum to linear constraints.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.SymmetricAllDifferent2AllDifferentInverseBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.SymmetricAllDifferent2AllDifferentInverseBridge","text":"Bridges CP.SymmetricAllDifferent to CP.AllDifferent and CP.Inverse.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.ValuePrecedence2ReificationBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.ValuePrecedence2ReificationBridge","text":"Bridges CP.ValuePrecedence to reification.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.VectorDomain2MILPBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.VectorDomain2MILPBridge","text":"Bridges CP.VectorDomain to MILP by adding one binary variable per  possible combination.\n\n\n\n\n\n","category":"type"},{"location":"mappings/facile/#Facile","page":"Facile","title":"Facile","text":"","category":"section"},{"location":"mappings/facile/","page":"Facile","title":"Facile","text":"http://facile.recherche.enac.fr/doc/","category":"page"},{"location":"reference/sets/","page":"Sets","title":"Sets","text":"CurrentModule = ConstraintProgrammingExtensions","category":"page"},{"location":"reference/sets/#sets_ref","page":"Sets","title":"Sets","text":"","category":"section"},{"location":"reference/sets/#Generic-CP-sets","page":"Sets","title":"Generic CP sets","text":"","category":"section"},{"location":"reference/sets/#Domain-of-variables","page":"Sets","title":"Domain of variables","text":"","category":"section"},{"location":"reference/sets/","page":"Sets","title":"Sets","text":"Domain\nVectorDomain\nAntiDomain\nVectorAntiDomain\nMembership","category":"page"},{"location":"reference/sets/#ConstraintProgrammingExtensions.Domain","page":"Sets","title":"ConstraintProgrammingExtensions.Domain","text":"Domain{T <: Number}(values::Set{T})\n\nThe set corresponding to an enumeration of constant values.\n\nThe value of a scalar function is enforced to take a value from this set of values.\n\nThis constraint is sometimes called in, member or allowed_assignments. https://sofdem.github.io/gccat/gccat/Cdomain.html\n\nExample\n\nx in Domain(1:3)\n# enforces `x == 1` OR `x == 2` OR `x == 3`.\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.VectorDomain","page":"Sets","title":"ConstraintProgrammingExtensions.VectorDomain","text":"VectorDomain{T <: Number}(dimension::Int, values::Set{Vector{T}})\n\nThe set corresponding to an enumeration of constant values.\n\nThe value of a vector function is enforced to take a value from this set of vector values.\n\nThis constraint is sometimes called in, member or allowed_assignments. https://sofdem.github.io/gccat/gccat/Cdomain.html\n\nExample\n\n[x, y] in Domain(2, Set([[1, 2], [2, 3]]))\n# enforces (`x == 1` AND `y == 2`) OR (`x == 2` AND `y == 3`).\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.AntiDomain","page":"Sets","title":"ConstraintProgrammingExtensions.AntiDomain","text":"AntiDomain{T <: Number}(values::Set{T})\n\nThe set corresponding to an enumeration of constant values that are excluded.\n\nThe value of a scalar function is enforced to take a value that is not from  this set of values.\n\nThis constraint is sometimes called (not_in)[https://sofdem.github.io/gccat/gccat/Cnotin.html], `notmember,rel,forbiddenassignments, ornogood`.\n\nExample\n\nx in AntiDomain(1:3)\n# enforces `x != 1` AND `x != 2` AND `x != 3`.\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.VectorAntiDomain","page":"Sets","title":"ConstraintProgrammingExtensions.VectorAntiDomain","text":"VectorAntiDomain{T <: Number}(values::Set{T})\n\nThe set corresponding to an enumeration of constant values that are excluded.\n\nThe value of a vector function is enforced to take a value that is not from  this set of vector values.\n\nThis constraint is sometimes called (not_in)[https://sofdem.github.io/gccat/gccat/Cnotin.html], `notmember,rel,forbiddenassignments, ornogood`.\n\nExample\n\n[x, y] in VectorAntiDomain(2, Set([[1, 2], [2, 3]]))\n# enforces (`x != 1` AND `y != 2`) OR (`x != 2` AND `y != 3`).\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.Membership","page":"Sets","title":"ConstraintProgrammingExtensions.Membership","text":"Membership(dimension)\n\nThe first element of a function of dimension dimension must equal at least one of the following dimension - 1 elements of the function.\n\nThis constraint is sometimes called in_set.\n\nExample\n\n[x, y, z] in Membership(3)\n# enforces `x == y` OR `x == z`.\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#Array-indexing","page":"Sets","title":"Array indexing","text":"","category":"section"},{"location":"reference/sets/","page":"Sets","title":"Sets","text":"Element\nElementVariableArray","category":"page"},{"location":"reference/sets/#ConstraintProgrammingExtensions.Element","page":"Sets","title":"ConstraintProgrammingExtensions.Element","text":"Element{T <: Real}(values::Vector{T})\n\n(x i) in mathbbR times mathbbN  x = valuesi\n\nLess formally, the first element constrained in this set will take the value of values at the index given by the second element.\n\nAlso called indexing  or nth.\n\nExamples\n\n[x, 3] in Element([4, 5, 6])\n# Enforces that x = 6, because 6 is the 3rd element from the array.\n\n[y, j] in Element([4, 5, 6])\n# Enforces that y = array[j], depending on the value of j (an integer\n# between 1 and 3).\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.ElementVariableArray","page":"Sets","title":"ConstraintProgrammingExtensions.ElementVariableArray","text":"ElementVariableArray(dimension::Int)\n\n(x i values) in mathbbR times mathbbN times mathbbR^mathttdimension  x = valuesi\n\nLess formally, the first element constrained in this set will take the value of values at the index given by the second element in the array given by the  remaining elements constrained in the set.\n\nExamples\n\n[x, 3, a, b, c] in ElementVariableArray(3)\n# Enforces that x = c, because 6 is the 3rd element from the array [a, b, c].\n\n[y, j, a, b, c] in ElementVariableArray(3)\n# Enforces that y = array[j], depending on the value of j (an integer\n# between 1 and 3), from the array [a, b, c].\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#Others","page":"Sets","title":"Others","text":"","category":"section"},{"location":"reference/sets/","page":"Sets","title":"Sets","text":"AllEqual\nAllDifferent\nAllDifferentExceptConstants\nAllDifferentExceptConstant\nSymmetricAllDifferent\nDifferentFrom\nMinimumDistance\nMaximumDistance\nInverse\nSlidingSum\nValuePrecedence","category":"page"},{"location":"reference/sets/#ConstraintProgrammingExtensions.AllEqual","page":"Sets","title":"ConstraintProgrammingExtensions.AllEqual","text":"AllEqual(dimension::Int)\n\nThe set corresponding to an all-equal constraint.\n\nAll expressions of a vector-valued function are enforced to take the same value in the solution.\n\nExample\n\n[x, y, z] in AllEqual(3)\n# enforces `x == y` AND `x == z`.\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.AllDifferent","page":"Sets","title":"ConstraintProgrammingExtensions.AllDifferent","text":"AllDifferent(dimension::Int)\n\nThe set corresponding to an all-different constraint.\n\nAll expressions of a vector-valued function are enforced to take distinct values in the solution: for all pairs of expressions, their values must differ.\n\nThis constraint is sometimes called distinct.\n\nExample\n\n[x, y, z] in AllDifferent(3)\n# enforces `x != y` AND `x != z` AND `y != z`.\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.AllDifferentExceptConstants","page":"Sets","title":"ConstraintProgrammingExtensions.AllDifferentExceptConstants","text":"AllDifferentExceptConstants{T <: Number}(dimension::Int, k::Set{T})\n\nAll expressions of a vector-valued function are enforced to take distinct values in the solution, but values equal to any value in k are not  considered: for all pairs of expressions, either their values must differ or at least one of the two variables has a value in k.\n\nThis constraint is sometimes called distinct.\n\nExample\n\n[x, y] in AllDifferentExceptConstant(2, 0)\n# enforces `x != y` OR `x == 0` OR `y == 0`.\n\n[x, y] in AllDifferentExceptConstant(2, Set([0, 1]))\n# enforces `x != y` OR `x == 0` OR `y == 0` OR `x == 1` OR `y == 1`.\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.AllDifferentExceptConstant","page":"Sets","title":"ConstraintProgrammingExtensions.AllDifferentExceptConstant","text":"Special case of AllDifferentExceptConstants where only one value is  ignored.\n\n\n\n\n\n","category":"function"},{"location":"reference/sets/#ConstraintProgrammingExtensions.SymmetricAllDifferent","page":"Sets","title":"ConstraintProgrammingExtensions.SymmetricAllDifferent","text":"SymmetricAllDifferent(dimension::Int)\n\nThe set corresponding to an all-different constraint, with the additional  requirement that the array must be symmetric.\n\nAll expressions of a vector-valued function are enforced to take distinct values in the solution: for all pairs of expressions, their values must differ. Symmetry means that, if xi=j, then xj=i.\n\nThis constraint is sometimes called symmetric_alldifferent.\n\nExample\n\n[x, y, z] in SymmetricAllDifferent(3)\n# enforces `x != y` AND `x != z` AND `y != z` AND `(x == 2 => y == 1)` AND \n# `(x == 3 => z = 1)` AND `(y == 1 => x == 2)` AND `(y == 3 => z == 2)` AND \n# `(z == 1 => x == 3)` AND `(z == 2 => y == 3)`.\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.DifferentFrom","page":"Sets","title":"ConstraintProgrammingExtensions.DifferentFrom","text":"DifferentFrom{T <: Number}(value::T)\n\nThe set excluding the single point x in mathbbR where x is given by value.\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.MinimumDistance","page":"Sets","title":"ConstraintProgrammingExtensions.MinimumDistance","text":"MinimumDistance{T <: Real}(dimension::Int, k::T)\n\nEnsures that all the dimension expressions in this set are at least k  apart, in absolute value:\n\nBigx in mathbbS^mathttdimension Big x_i - x_j geq k forall i neq j in 1 2dots mathttdimension Big\n\nAlso called all_min_dist  or inter_distance.\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.MaximumDistance","page":"Sets","title":"ConstraintProgrammingExtensions.MaximumDistance","text":"MaximumDistance{T <: Real}(dimension::Int, k::T)\n\nEnsures that all the dimension expressions in this set are at most k  apart, in absolute value:\n\nBigx in mathbbS^mathttdimension Big x_i - x_j leq k forall i neq j in 1 2dots mathttdimension Big\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.Inverse","page":"Sets","title":"ConstraintProgrammingExtensions.Inverse","text":"Inverse(dimension::Int)\n\nEnsures that the two arrays of variables of size dimension are the inverse  one of the other. \n\nBig(x y) in mathbbR^mathttdimension times mathbbR^dimension Big x_i = j iff y_j = i forall i j in 1 2 dots mathttdimension Big\n\nIndices start at 1, like Julia.\n\nAlso called channel,  inverse_channeling, or assignment.\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.SlidingSum","page":"Sets","title":"ConstraintProgrammingExtensions.SlidingSum","text":"SlidingSum{T}(low::T, high::T, length::Int, dimension::Int)\n\nEnsures that the sum of all sequences of size length have a value between low and high. \n\nx in mathbbR^mathttdimension  mathttlow leq sum_j=i^i+mathttlength-1 x_i leq mathtthigh forall i in  0 1 dots mathttdimension - mathttlength  \n\nhttps://sofdem.github.io/gccat/gccat/Csliding_sum.html\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.ValuePrecedence","page":"Sets","title":"ConstraintProgrammingExtensions.ValuePrecedence","text":"ValuePrecedence(before::T, value::T, dimension::Int)\n\nEnsures that the value before happens before value in the array of size  dimension. \n\nx in mathbbR^mathttdimension  exists i  j x_i = mathttbefore x_j = mathttvalue \n\nAlso called precede or value_precede.\n\nhttps://sofdem.github.io/gccat/gccat/Cintvalueprecede.html\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#Combinatorial-constraints","page":"Sets","title":"Combinatorial constraints","text":"","category":"section"},{"location":"reference/sets/","page":"Sets","title":"Sets","text":"Contiguity","category":"page"},{"location":"reference/sets/#ConstraintProgrammingExtensions.Contiguity","page":"Sets","title":"ConstraintProgrammingExtensions.Contiguity","text":"Contiguity(dimension::Int)\n\nEnsures that, in the binary variables x constrained to be in this set,  all the 1s are contiguous. The vector must correspond to the regular expression 0*1*0*.\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#Bin-packing","page":"Sets","title":"Bin packing","text":"","category":"section"},{"location":"reference/sets/","page":"Sets","title":"Sets","text":"BinPacking\nBinPackingCapacityType","category":"page"},{"location":"reference/sets/#ConstraintProgrammingExtensions.BinPacking","page":"Sets","title":"ConstraintProgrammingExtensions.BinPacking","text":"BinPacking(n_bins::Int, n_items::Int, weights::Vector{T})\n\nUncapacitated bin packing\n\nImplements an uncapacitated version of the bin-packing problem.\n\nThe first n_bins variables give the load in each bin, the last n_items give the number of the bin to which the item is assigned to. \n\nThe load of a bin is defined as the sum of the sizes of the items put in that  bin.\n\nAlso called pack.\n\nExample\n\n[a, b, c] in BinPacking{NO_CAPACITY_BINPACKING}(1, 2, [2, 3])\n# As there is only one bin, the only solution is to put all the items in \n# that bin.\n# Enforces that:\n# - the bin load is the sum of the weights of the objects in that bin: \n#   a = 2 + 3\n# - the bin number of the two items is 1: b = c = 1\n\nFixed-capacity bin packing\n\nImplements a capacitated version of the bin-packing problem where capacities are constant.\n\nThe first n_bins variables give the load in each bin, the last n_items  give the number of the bin to which the item is assigned to. \n\nThe load of a bin is defined as the sum of the sizes of the items put in that  bin.\n\nThis constraint is equivalent to BinPacking with inequality constraints on  the loads of the bins where the upper bound is a constant. However, there are  more efficient propagators for the combined constraint (bin packing with  maximum load); if such propagators are not available, bridges are available to make the conversion seamless.\n\nAlso called bin_packing_capa.\n\nExample\n\n[a, b, c] in BinPacking{FIXED_CAPACITY_BINPACKING}(1, 2, [2, 3], [4])\n# As there is only one bin, the only solution is to put all the items in\n# that bin if its capacity is large enough.\n# Enforces that:\n# - the bin load is the sum of the weights of the objects in that bin: \n#   a = 2 + 3\n# - the bin load is at most its capacity: a <= 4 (given in the set)\n# - the bin number of the two items is 1: b = c = 1\n\nVariable-capacity bin packing\n\nImplements an capacitated version of the bin-packing problem where capacities  are optimisation variables.\n\nThe first n_bins variables give the load in each bin, the next n_bins are the capacity of each bin, the last n_items give the number of the bin to which the item is assigned to.\n\nThe load of a bin is defined as the sum of the sizes of the items put in that  bin.\n\nThis constraint is equivalent to BinPacking with inequality constraints on  the loads of the bins where the upper bound is any expression. However, there  are more efficient propagators for the combined constraint (bin packing with  maximum load) and for the fixed-capacity version.\n\nAlso called bin_packing_capa.\n\nExample\n\n[a, 2, b, c] in BinPacking{VARIABLE_CAPACITY_BINPACKING}(1, 2, [2, 3])\n# As there is only one bin, the only solution is to put all the items in\n# that bin if its capacity is large enough.\n# Enforces that:\n# - the bin load is the sum of the weights of the objects in that bin: \n#   a = 2 + 3\n# - the bin load is at most its capacity: a <= 2 (given in a variable)\n# - the bin number of the two items is 1: b = c = 1\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.BinPackingCapacityType","page":"Sets","title":"ConstraintProgrammingExtensions.BinPackingCapacityType","text":"BinPackingCapacityType\n\nWhether the capacities of a BinPacking constraint are fixed:\n\neither there is no capacity: NO_CAPACITY_BINPACKING\nor the capacity values are fixed when creating the set: FIXED_CAPACITY_BINPACKING\nor the capacity values are themselves variable: VARIABLE_CAPACITY_BINPACKING\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#Knapsack","page":"Sets","title":"Knapsack","text":"","category":"section"},{"location":"reference/sets/","page":"Sets","title":"Sets","text":"Knapsack\nKnapsackCapacityType\nKnapsackValueType","category":"page"},{"location":"reference/sets/#ConstraintProgrammingExtensions.Knapsack","page":"Sets","title":"ConstraintProgrammingExtensions.Knapsack","text":"Knapsack{KCT, KVT, T <: Real}(weights::T, capacity::Vector{T})\n\nFixed capacity, unvalued\n\nEnsures that the n variables respect a knapsack constraint with fixed weights and a fixed capacity: \n\nx in 0 1^n  sum_i=1^n mathttweightsi x_i leq mathttcapacity .\n\nVariable capacity, unvalued\n\nEnsures that the first n variables respect a knapsack constraint with fixed weights and a capacity given by the last variable: \n\n(x y) in 0 1^n times mathbbR  sum_i=1^n mathttweightsi x_i leq y .\n\nFixed capacity, valued\n\nEnsures that the n first variables respect a knapsack constraint with fixed  weights and a fixed capacity, the last variable being the total value of the  knapsack: \n\n(x y) in 0 1^n times mathbbR  sum_i=1^n mathttweightsi x_i leq mathttcapacity land y = sum_i=1^n mathttvaluesi x_i .\n\nVariable capacity, valued\n\nEnsures that the first n variables respect a knapsack constraint with  fixed weights and a capacity given by the last-but-one variable; the total  value is the last variable: \n\n(x y z) in 0 1^n times mathbbR times mathbbR  sum_i=1^n mathttweightsi x_i leq y land z = sum_i=1^n mathttvaluesi x_i .\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.KnapsackCapacityType","page":"Sets","title":"ConstraintProgrammingExtensions.KnapsackCapacityType","text":"KnapsackCapacityType\n\nWhether the capacity of a Knapsack constraint is fixed:\n\neither the value is fixed when creating the set: FIXED_CAPACITY_KNAPSACK\nor the value is itself variable: VARIABLE_CAPACITY_KNAPSACK\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.KnapsackValueType","page":"Sets","title":"ConstraintProgrammingExtensions.KnapsackValueType","text":"KnapsackValueType\n\nWhether the value of a Knapsack constraint is needed:\n\neither the value is not available: UNVALUED_KNAPSACK\nor the value is available as a new variable: VALUED_KNAPSACK\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#Counting-constraints","page":"Sets","title":"Counting constraints","text":"","category":"section"},{"location":"reference/sets/","page":"Sets","title":"Sets","text":"Count\nCountCompare\nCountDistinct","category":"page"},{"location":"reference/sets/#ConstraintProgrammingExtensions.Count","page":"Sets","title":"ConstraintProgrammingExtensions.Count","text":"Count{S <: MOI.AbstractScalarSet}(dimension::Int, set::MOI.AbstractScalarSet)\n\n(y x) in mathbbN times mathbbT^mathttdimension  y = i  x_i in S \n\ndimension is the number of variables that are checked against the set.\n\nAlso called among.\n\nExample\n\n[w, x, y, z] in Count(3, MOI.EqualTo(2.0))\n# w == sum([x, y, z] .== 2.0)\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.CountCompare","page":"Sets","title":"ConstraintProgrammingExtensions.CountCompare","text":"CountCompare(dimension::Int)\n\n(z x y) in mathbbN times mathbbR^mathttdimension times mathbbR^mathttdimension  Z = i  x_i = y_i\n\nThe first dimension variables are the first array that is compared to the  second one, indicated by the next dimension variables. The last variable is the number of values that are identical in both arrays.\n\nExample\n\n[v, w, x, y, z] in Count(2)\n# w == sum([w, x] .== [y, z])\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.CountDistinct","page":"Sets","title":"ConstraintProgrammingExtensions.CountDistinct","text":"CountDistinct(dimension::Int)\n\nThe first variable in the set is forced to be the number of distinct values in the rest of the expressions.\n\nThis is a relaxed version of AllDifferent; it encodes an AllDifferent constraint when the first variable is the number of variables in the set.\n\nAlso called nvalues.\n\nExample\n\n[x, y, z] in CountDistinct(3)\n# x = 1 if y == z, x = 2 if y != z\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#Global-cardinality","page":"Sets","title":"Global cardinality","text":"","category":"section"},{"location":"reference/sets/","page":"Sets","title":"Sets","text":"GlobalCardinality\nCountedValuesType\nCountedValuesClosureType","category":"page"},{"location":"reference/sets/#ConstraintProgrammingExtensions.GlobalCardinality","page":"Sets","title":"ConstraintProgrammingExtensions.GlobalCardinality","text":"GlobalCardinality{CVT, CVCT, T}(dimension::Int, values::Vector{T})\n\nThis set represents the large majority of the variants of the  global-cardinality constraint, with the parameters set in CountedValuesType  (CVT parameter) and CountedValuesClosureType (CVCT parameter).\n\nFixed and open\n\n(x y) in mathbbT^mathttdimension times mathbbN^d  y_i =  j  x_j = mathttvalues_i forall j  \n\nThe first dimension variables are an array, the last variables are the  number of times that each item of values is present in the first array. Values that are not in values are ignored. \n\nAlso called gcc or count.\n\nExample\n\n[x, y, z, v, w] in GlobalCardinality{FIXED_COUNTED_VALUES, OPEN_COUNTED_VALUES}(3, [2.0, 4.0])\n[x, y, z, v, w] in GlobalCardinality{OPEN_COUNTED_VALUES}(3, [2.0, 4.0])\n[x, y, z, v, w] in GlobalCardinality(3, [2.0, 4.0])\n# v == sum([x, y, z] .== 2.0)\n# w == sum([x, y, z] .== 4.0)\n\nVariable and open\n\n(x y z) in mathbbT^mathttdimension times mathbbN^mathttn_values times mathbbT^mathttn_values  y_i =  j  x_j = z_i forall j  \n\nThe first dimension variables are an array, the next n_values variables  are the number of times that each item of the last n_values variables is  present in the first array. Values of the first array that are not in the  n_values are ignored. \n\nAlso called distribute.\n\nExample\n\n[x, y, z, t, u, v, w] in GlobalCardinality{VARIABLE_COUNTED_VALUES, OPEN_COUNTED_VALUES, T}(3, 2)\n[x, y, z, t, u, v, w] in GlobalCardinality{OPEN_COUNTED_VALUES, T}(3, 2)\n[x, y, z, t, u, v, w] in GlobalCardinality{T}(3, 2)\n# t == sum([x, y, z] .== v)\n# u == sum([x, y, z] .== w)\n\nFixed and closed\n\n(x y) in mathbbT^mathttdimension times mathbbN^d  y_i =  j  x_j = mathttvalues_i forall j  \n\nThe first dimension variables are an array, the last variables are the  number of times that each item of values is present in the first array. Each value of the first array must be within values.\n\nExample\n\n[x, y, z, v, w] in GlobalCardinality{FIXED_COUNTED_VALUES, CLOSED_COUNTED_VALUES, T}(3, [2.0, 4.0])\n# v == sum([x, y, z] .== 2.0)\n# w == sum([x, y, z] .== 4.0)\n# x ∈ [2.0, 4.0], y ∈ [2.0, 4.0], z ∈ [2.0, 4.0]\n\nVariable and closed\n\n(x y z) in mathbbT^mathttdimension times mathbbN^mathttn_values times mathbbT^mathttn_values  y_i =  j  x_j = z_i forall j  \n\nThe first dimension variables are an array, the next n_values variables  are the number of times that each item of the last n_values variables is  present in the first array. Each value of the first array must be within the  next given n_values.\n\nAlso called distribute.\n\nExample\n\n[x, y, z, t, u, v, w] in GlobalCardinality{VARIABLE_COUNTED_VALUES, CLOSED_COUNTED_VALUES, T}(3, 2)\n# t == sum([x, y, z] .== v)\n# u == sum([x, y, z] .== w)\n# x ∈ [v, w], y ∈ [v, w], z ∈ [v, w]\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.CountedValuesType","page":"Sets","title":"ConstraintProgrammingExtensions.CountedValuesType","text":"CountedValuesType\n\nKind of values to be counted for a GlobalCardinality constraint:\n\neither the values to count are fixed when creating the set: FIXED_COUNTED_VALUES\nor the values are themselves variables (typically constrained elsewhere):  VARIABLE_COUNTED_VALUES\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.CountedValuesClosureType","page":"Sets","title":"ConstraintProgrammingExtensions.CountedValuesClosureType","text":"CountedValuesClosureType\n\nWhether values that are not counted in GlobalCardinality constraint are  allowed in the array whose values are counted:\n\neither uncounted values are allowed: OPEN_COUNTED_VALUES\nor they are not allowed: CLOSED_COUNTED_VALUES\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#Graph-constraints","page":"Sets","title":"Graph constraints","text":"","category":"section"},{"location":"reference/sets/","page":"Sets","title":"Sets","text":"Circuit\nCircuitPath\nWeightedCircuit\nWeightedCircuitPath","category":"page"},{"location":"reference/sets/#ConstraintProgrammingExtensions.Circuit","page":"Sets","title":"ConstraintProgrammingExtensions.Circuit","text":"Circuit(n_nodes::Int)\n\nA Hamiltonian circuit. If the vector x is constrained within a Circuit(n), each x[i] denotes the next node in the graph, for i ∈ [1, n]. \n\nThe considered graph is an undirected complete graph with n nodes.\n\nAlso called cycle or atour.\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.CircuitPath","page":"Sets","title":"ConstraintProgrammingExtensions.CircuitPath","text":"CircuitPath(n_nodes::Int)\n\nA Hamiltonian circuit. If the vectors x and y are constrained within a  CircuitPath(n), each x[i] denotes the next node in the graph, for  i ∈ [1, n]. The last n variables denote the order in which the nodes are visited, i.e. y[1] is the first visited node (1 by convention), y[2] is  the next node in the path, etc.\n\nThe considered graph is an undirected complete graph with n nodes.\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.WeightedCircuit","page":"Sets","title":"ConstraintProgrammingExtensions.WeightedCircuit","text":"WeightedCircuit{T <: Real}(n_nodes::Int, cost_matrix::AbstractMatrix{T})\n\nA Hamiltonian circuit. If the vector x and the scalar c are constrained within a WeightedCircuit(n, cost_matrix), each x[i] denotes the next node  in the graph, for i ∈ [1, n]. c is the total cost of the circuit, defined as: \n\nc = sum_i=1^n mathttcost_matrix_i xi\n\nThe considered graph is an undirected complete graph with n nodes.\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.WeightedCircuitPath","page":"Sets","title":"ConstraintProgrammingExtensions.WeightedCircuitPath","text":"WeightedCircuitPath(n_nodes::Int, cost_matrix::AbstractMatrix{T})\n\nA Hamiltonian circuit. If the vectors x and y and the scalar c are  constrained within a CircuitPath(n), each x[i] denotes the next node in the graph, for  i ∈ [1, n]. The next n variables denote the order in which the nodes are visited, i.e. y[1] is the first visited node (1 by convention), y[2] is  the next node in the path, etc. c is the total cost of the circuit, defined as: \n\nc = sum_i=1^n mathttcost_matrix_i xi\n\nThe considered graph is an undirected complete graph with n nodes.\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#Reification-constraints","page":"Sets","title":"Reification constraints","text":"","category":"section"},{"location":"reference/sets/","page":"Sets","title":"Sets","text":"Reification\nEquivalence\nEquivalenceNot\nIfThenElse\nImplication\nConjunction\nDisjunction\nNegation\nTrue\nFalse","category":"page"},{"location":"reference/sets/#ConstraintProgrammingExtensions.Reification","page":"Sets","title":"ConstraintProgrammingExtensions.Reification","text":"Reification{S <: MOI.AbstractSet}(set::S)\n\n(y x) in 0 1 times mathbbR^n  y = 1 iff x in set y = 0 otherwise.\n\nThis set serves to find out whether a given constraint is satisfied.\n\nThe only possible values are 0 and 1 for the first variable of the set.\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.Equivalence","page":"Sets","title":"ConstraintProgrammingExtensions.Equivalence","text":"Equivalence{S1 <: MOI.AbstractSet, S2 <: MOI.AbstractSet}(set1::S1, \n                                                          set2::S2)\n\nThe logical equivalence operator ≡ or ⇔.\n\n(x y) in mathbbR^a+b  x in S1 iff y in S2.\n\nThe two constraints must be either satisfied or not satisfied at the same time. More explicitly, if the first one is satisfied, then the second one is implied to be satisfied too; if the second one is satisfied, then the first one is  implied.\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.EquivalenceNot","page":"Sets","title":"ConstraintProgrammingExtensions.EquivalenceNot","text":"EquivalenceNot{S1 <: MOI.AbstractSet, S2 <: MOI.AbstractSet}(set1::S1,                                                                  set2::S2)\n\nThe logical equivalence operator ≡ or ⇔, with the second argument negated.\n\n(x y) in mathbbR^a+b  x in S1 iff y notin S2.\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.IfThenElse","page":"Sets","title":"ConstraintProgrammingExtensions.IfThenElse","text":"IfThenElse{\n    Condition <: MOI.AbstractSet, \n    TrueConstraint <: MOI.AbstractSet, \n    FalseConstraint <: MOI.AbstractSet\n}(condition::Condition, true_constraint::TrueConstraint, \n  false_constraint::FalseConstraint)\n\nThe ternary operator.\n\nIf the condition is satisfied, then the first constraint (of type  TrueConstraint) will be implied. Otherwise, the second constraint (of type FalseConstraint) will be implied.\n\n(x y z) in mathbbR^(a+b+c)  y in TrueConstraint iff x in set z in FalseConstraint otherwise.\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.Implication","page":"Sets","title":"ConstraintProgrammingExtensions.Implication","text":"Implication{\n    Antecedent <: MOI.AbstractSet,\n    Consequent <: MOI.AbstractSet\n}(antecedent::Antecedent, consequent::Consequent)\n\nThe logical implication operator ⇒.\n\nIf the antecedent is satisfied, then the consequent will be implied to be  satisfied. Otherwise, nothing is implied on the truth value of consequent.\n\n(x y) in mathbbR^a times mathbbR^b  y in Consequent if x in Antecedent.\n\nAlso called if_then, material implication, or material conditional.\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.Conjunction","page":"Sets","title":"ConstraintProgrammingExtensions.Conjunction","text":"Conjunction{Ts}(constraints::Ts)\n\nThe logical conjunction operator ∧ (AND): all the constraints in the  conjunction must be satisfied.\n\n(x ydots) in mathbbR^a times mathbbR^bdots  x in mathbbS_1 land y in mathbbS_2 dots .\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.Disjunction","page":"Sets","title":"ConstraintProgrammingExtensions.Disjunction","text":"Disjunction{Ts}(constraints::Ts)\n\nThe logical disjunction operator ∨ (OR): at least one of the constraints in  the disjunction must be satisfied.\n\n(x ydots) in mathbbR^a times mathbbR^bdots  x in mathbbS_1 lor y in mathbbS_2 dots .\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.Negation","page":"Sets","title":"ConstraintProgrammingExtensions.Negation","text":"Negation{S <: MOI.AbstractSet}(set::S)\n\nThe logical negation operator ¬ (NOT).\n\nx in times mathbbR^n  x notin set.\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.True","page":"Sets","title":"ConstraintProgrammingExtensions.True","text":"True()\n\nA constraint that is always true. \n\nIt is only useful with reification-like constraints.\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.False","page":"Sets","title":"ConstraintProgrammingExtensions.False","text":"False()\n\nA constraint that is always false. \n\nIt is only useful with reification-like constraints.\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#Scheduling-constraints","page":"Sets","title":"Scheduling constraints","text":"","category":"section"},{"location":"reference/sets/#Cumulative-resource","page":"Sets","title":"Cumulative resource","text":"","category":"section"},{"location":"reference/sets/","page":"Sets","title":"Sets","text":"CumulativeResource\nCumulativeResourceDeadlineType","category":"page"},{"location":"reference/sets/#ConstraintProgrammingExtensions.CumulativeResource","page":"Sets","title":"ConstraintProgrammingExtensions.CumulativeResource","text":"CumulativeResource{CRDT}(n_tasks::Int)\n\nThis set models most variants of task scheduling with cumulative resource  usage. Presence of deadlines can be indicated with the  CumulativeResourceDeadlineType enumeration.\n\nWithout deadline\n\nEach task is given by a minimum start time (the first n_tasks variables),  a duration (the next n_tasks variables), and the resource consumption  (the following n_tasks variables). The final variable is the maximum amount of the resource available.\n\nAlso called cumulative. This version does not consider end deadlines for tasks.\n\nWith variable deadline\n\nEach task is given by a minimum start time (the first n_tasks variables),  a duration (the next n_tasks variables), a deadline (the following n_tasks  variables), and the resource consumption (the next n_tasks variables).  The final variable is the maximum amount of the resource available.\n\nAlso called cumulative\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.CumulativeResourceDeadlineType","page":"Sets","title":"ConstraintProgrammingExtensions.CumulativeResourceDeadlineType","text":"CumulativeResourceDeadlineType\n\nWhether resources in CumulativeResource constraint have deadlines:\n\neither there are no deadlines: NO_DEADLINE_CUMULATIVE_RESOURCE\nor deadlines are given as variables: VARIABLE_DEADLINE_CUMULATIVE_RESOURCE\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#Non-overlapping-orthotopes","page":"Sets","title":"Non-overlapping orthotopes","text":"","category":"section"},{"location":"reference/sets/","page":"Sets","title":"Sets","text":"NonOverlappingOrthotopes\nNonOverlappingOrthotopesConditionalityType","category":"page"},{"location":"reference/sets/#ConstraintProgrammingExtensions.NonOverlappingOrthotopes","page":"Sets","title":"ConstraintProgrammingExtensions.NonOverlappingOrthotopes","text":"NonOverlappingOrthotopes{NOOCT}(n_orthotopes::Int, n_dimensions::Int)\n\nThis set corresponds to a guarantee that orthotopes do not overlap. Some  orthotopes can optionally be disabled for the constraint (guided by variables), based on the value of NonOverlappingOrthotopesConditionalityType.\n\nUnconditional constraint\n\nGuarantees that the n_orthotopes orthotopes do not overlap. The orthotopes  live in various dimensions: segments if n_dimensions = 1, rectangles if  n_dimensions = 2, rectangular parallelepiped if n_dimensions = 3,  hyperrectangles otherwise.\n\nThe variables are packed by orthotope: \n\nthe first n_dimensions are the origin of the orthotope\nthe next n_dimensions are the size of the orthotope in each dimension\nthe last n_dimensions are the destination of the orthotope. These variables are automatically constrained to be origin + size (unlike other modelling  layers, such as Gecode)\n\nThe set can be defined as: \n\n(o_1 s_1 d_1 o_2 s_2 d_2 dots o_mathtto s_mathtto d_mathtto) in mathbbR^3 times mathtto times mathttd \n\nAlso called diffn,  geost, nooverlap, diff2, or disjoint.\n\nExample: two 2-D rectangles\n\n[x1, y1, w1, h1, x1e, y1e, x2, y2, w2, h2, x2e, y2e] in NonOverlappingOrthotopes(2, 2)\n# Enforces the following five constraints: \n#   OR(\n#     x1 + w1 <= x2,\n#     x2 + w2 <= x1,\n#     y1 + h1 <= y2,\n#     y2 + h2 <= y1\n#   )\n#   x1e = x1 + w1\n#   y1e = y1 + h1\n#   x2e = x2 + w2\n#   y2e = y2 + h2\n\nConditional constraint\n\nGuarantees that the n_orthotopes orthotopes do not overlap, with a binary  variable indicating whether a given orthotope must not overlap with other  orthotopes (if 1) or if it can be ignored (if 0). The orthotopes live in  various dimensions: segments if n_dimensions = 1, rectangles if  n_dimensions = 2, rectangular parallelepiped if n_dimensions = 3,  hyperrectangles otherwise.\n\nThe variables are packed by orthotope: \n\nthe first n_dimensions are the origin of the orthotope\nthe next n_dimensions are the size of the orthotope in each dimension\nthe next n_dimensions are the destination of the orthotope. These variables are automatically constrained to be origin + size (unlike other modelling  layers, such as Gecode)\nthe last variable indicates whether the orthotope is mandatory (true) or  optional (false)\n\nThe set can be defined as: \n\n(o_1 s_1 d_1 m_1 o_2 s_2 d_2 m_2 dots o_mathtto s_mathtto d_mathtto m_mathtto) in prod_i=1^mathtto (mathbbR^3 times mathttd times 0 1) \n\nAlso called diffn,  nooverlap, or disjointconditional.\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.NonOverlappingOrthotopesConditionalityType","page":"Sets","title":"ConstraintProgrammingExtensions.NonOverlappingOrthotopesConditionalityType","text":"NonOverlappingOrthotopesConditionalityType\n\nWhether orthotopes in NonOverlappingOrthotopes constraint are considered:\n\neither all orthotopes must be considered: UNCONDITIONAL_NONVERLAPPING_ORTHOTOPES\nor orthotopes can be disabled by variables: CONDITIONAL_NONVERLAPPING_ORTHOTOPES\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#Sorting-constraints","page":"Sets","title":"Sorting constraints","text":"","category":"section"},{"location":"reference/sets/#Lexicographic-order","page":"Sets","title":"Lexicographic order","text":"","category":"section"},{"location":"reference/sets/","page":"Sets","title":"Sets","text":"LexicographicallyLessThan\nLexicographicallyGreaterThan\nDoublyLexicographicallyLessThan\nDoublyLexicographicallyGreaterThan","category":"page"},{"location":"reference/sets/#ConstraintProgrammingExtensions.LexicographicallyLessThan","page":"Sets","title":"ConstraintProgrammingExtensions.LexicographicallyLessThan","text":"LexicographicallyLessThan(row_dim::Int, column_dim::Int)\n\nEnsures that each column of the matrix is lexicographically less than  the next column. \n\nFormally, for two columns:\n\n(x y) in mathbbR^mathttcolumn_dim times mathbbR^mathttcolumn_dim  exists j in 1 2 dots mathttcolumn_dim x_j  y_j forall i  j x_i = y_i .\n\nAlso called lex_less.\n\nThe matrix is encoded by stacking the columns, matching the behaviour of Julia's vec function.\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.LexicographicallyGreaterThan","page":"Sets","title":"ConstraintProgrammingExtensions.LexicographicallyGreaterThan","text":"LexicographicallyGreaterThan(row_dim::Int, column_dim::Int)\n\nEnsures that each column of the matrix is lexicographically greater than  the next column. \n\nFormally, for two columns:\n\n(x y) in mathbbR^mathttcolumn_dim times mathbbR^mathttcolumn_dim  xists j in 1 2 dots mathttcolumn_dim x_j  y_j forall i  j x_i = y_i .\n\nAlso called lex_greater.\n\nThe matrix is encoded by stacking the columns, matching the behaviour of Julia's vec function.\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.DoublyLexicographicallyLessThan","page":"Sets","title":"ConstraintProgrammingExtensions.DoublyLexicographicallyLessThan","text":"DoublyLexicographicallyLessThan(dimension::Int)\n\nEnsures that each column of the matrix is lexicographically less than  the next column, and that each row of the matrix is lexicographically less  than the next row. \n\nAlso called lex2.\n\nThe matrix is encoded by stacking the columns, matching the behaviour of Julia's vec function.\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.DoublyLexicographicallyGreaterThan","page":"Sets","title":"ConstraintProgrammingExtensions.DoublyLexicographicallyGreaterThan","text":"DoublyLexicographicallyGreaterThan(dimension::Int)\n\nEnsures that each column of the matrix is lexicographically greater than  the next column, and that each row of the matrix is lexicographically greater  than the next row. \n\nThe matrix is encoded by stacking the columns, matching the behaviour of Julia's vec function.\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#Typical-order","page":"Sets","title":"Typical order","text":"","category":"section"},{"location":"reference/sets/","page":"Sets","title":"Sets","text":"Sort\nSortPermutation","category":"page"},{"location":"reference/sets/#ConstraintProgrammingExtensions.Sort","page":"Sets","title":"ConstraintProgrammingExtensions.Sort","text":"Sort(dimension::Int)\n\nEnsures that the first dimension elements is a sorted copy of the next dimension elements.\n\nExample\n\n[a, b, c, d] in Sort(2)\n# Enforces that:\n# - the first part is sorted: a <= b\n# - the first part corresponds to the second one:\n#     - either a = c and b = d\n#     - or a = d and b = c\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.SortPermutation","page":"Sets","title":"ConstraintProgrammingExtensions.SortPermutation","text":"SortPermutation(dimension::Int)\n\nEnsures that the first dimension elements is a sorted copy of the next dimension elements.\n\nThe last dimension elements give a permutation to get from the original array to its sorted version.\n\nExample\n\n[a, b, c, d, i, j] in SortPermutation(2)\n# Enforces that:\n# - the first part is sorted: a <= b\n# - the first part corresponds to the second one:\n#     - either a = c and b = d: in this case, i = 1 and j = 2\n#     - or a = d and b = c: in this case, i = 2 and j = 1\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#Extrema","page":"Sets","title":"Extrema","text":"","category":"section"},{"location":"reference/sets/","page":"Sets","title":"Sets","text":"MaximumAmong\nMinimumAmong\nArgumentMaximumAmong\nArgumentMinimumAmong","category":"page"},{"location":"reference/sets/#ConstraintProgrammingExtensions.MaximumAmong","page":"Sets","title":"ConstraintProgrammingExtensions.MaximumAmong","text":"MaximumAmong(dimension::Int)\n\nEnsures that the first element is the maximum value among the next  dimension elements.\n\nExample\n\n[a, b, c] in MaximumAmong(2)\n# Enforces that a == max(b, c)\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.MinimumAmong","page":"Sets","title":"ConstraintProgrammingExtensions.MinimumAmong","text":"MinimumAmong(dimension::Int)\n\nEnsures that the first element is the minimum value among the next  dimension elements.\n\nExample\n\n[a, b, c] in MinimumAmong(2)\n# Enforces that a == min(b, c)\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.ArgumentMaximumAmong","page":"Sets","title":"ConstraintProgrammingExtensions.ArgumentMaximumAmong","text":"ArgumentMaximumAmong(dimension::Int)\n\nEnsures that the first element is the index of the maximum value among the  next dimension elements.\n\nExample\n\n[a, b, c] in ArgumentMaximumAmong(2)\n# Enforces that a == argmax(b, c)\n# I.e., if b > c, a = 1, if b < c, a = 2\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.ArgumentMinimumAmong","page":"Sets","title":"ConstraintProgrammingExtensions.ArgumentMinimumAmong","text":"ArgumentMinimumAmong(dimension::Int)\n\nEnsures that the first element is the index of the minimum value among the  next dimension elements.\n\nExample\n\n[a, b, c] in ArgumentMinimumAmong(2)\n# Enforces that a == argmin(b, c)\n# I.e., if b < c, a = 1, if b > c, a = 2\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#Strict-constraints","page":"Sets","title":"Strict constraints","text":"","category":"section"},{"location":"reference/sets/","page":"Sets","title":"Sets","text":"Strictly","category":"page"},{"location":"reference/sets/#ConstraintProgrammingExtensions.Strictly","page":"Sets","title":"ConstraintProgrammingExtensions.Strictly","text":"Strictly{S <: Union{LessThan{T}, GreaterThan{T}, LexicographicallyGreaterThan}}\n\nConverts an inequality set to a set with the same inequality made strict. For example, while LessThan(1) corresponds to the inequality x <= 1, Strictly(LessThan(1)) corresponds to the inequality x < 1.\n\nExample\n\nx in Strictly(LessThan(1))\n\n\n\n\n\n","category":"type"},{"location":"#ConstraintProgrammingExtensions.jl","page":"Introduction","title":"ConstraintProgrammingExtensions.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This package provides extensions to  MathOptInterface in order to support constraint programming. This allows to use the same user model with several solvers. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"On top of providing a uniform interface, this package also implements a  quantity of bridges, i.e. reformulations of constraints, to bridge the gap when a solver does not support a specific constraint. In particular, the set  of bridges should make it possible to transform any CP model into a MIP model.","category":"page"},{"location":"#Citing-ConstraintProgrammingExtensions","page":"Introduction","title":"Citing ConstraintProgrammingExtensions","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Currently, there is no article or preprint that can be cited for CPE.  However, you can use the Zenodo DOI: ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@software{thibaut_cuvelier_2021_5122859,\n  author       = {Thibaut Cuvelier and\n                  Oscar Dowson},\n  title        = {{dourouc05/ConstraintProgrammingExtensions.jl: \n                   v0.3.0}},\n  month        = jul,\n  year         = 2021,\n  publisher    = {Zenodo},\n  version      = {v0.3.0},\n  doi          = {10.5281/zenodo.5122859},\n  url          = {https://doi.org/10.5281/zenodo.5122859}\n}","category":"page"}]
}
