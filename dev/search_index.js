var documenterSearchIndex = {"docs":
[{"location":"reference/bridges_sets/","page":"Set bridges","title":"Set bridges","text":"CurrentModule = ConstraintProgrammingExtensions.Bridges","category":"page"},{"location":"reference/bridges_sets/#Set-bridges","page":"Set bridges","title":"Set bridges","text":"","category":"section"},{"location":"reference/bridges_sets/","page":"Set bridges","title":"Set bridges","text":"AbsoluteValue2MILPBridge\nAllDifferent2DifferentFromBridge\nAllDifferentExceptConstants2ConjunctionDisjunctionBridge\nAllDifferentExceptConstants2ReificationBridge\nAllEqual2EqualToBridge\nArgumentMaximumAmong2MILPBridge\nArgumentMinimumAmong2MILPBridge\nBinPacking2MILPBridge\nFixedCapacityBinPacking2BinPackingBridge\nFixedCapacityBinPacking2VariableCapacityBinPackingBridge\nVariableCapacityBinPacking2BinPackingBridge\nVariableCapacityBinPacking2MILPBridge\nClosedGlobalCardinality2GlobalCardinalityBridge\nClosedGlobalCardinalityVariable2GlobalCardinalityVariableBridge\nConjunction2ReificationBridge\nCount2ReificationBridge\nCountCompare2CountBridge\nDecreasing2LPBridge\nDifferentFrom2PseudoMILPBridge\nIndicatorDifferentFrom2PseudoMILPBridge\nReificationDifferentFrom2IndicatorBridge\nReificationDifferentFrom2MILPBridge\nDisjunction2ReificationBridge\nDomain2MILPBridge\nDoublyLexicographicallyLessThan2LexicographicallyLessThanBridge\nDoublyLexicographicallyGreaterThan2LexicographicallyGreaterThanBridge\nElement2MILPBridge\nElementVariableArray2MILPBridge\nReificationEqualTo2IndicatorBridge\nReificationEqualTo2MILPBridge\nReificationGreaterThan2IndicatorBridge\nReificationGreaterThan2MILPBridge\nGlobalCardinality2CountBridge\nGlobalCardinality2GlobalCardinalityVariableBridge\nGlobalCardinalityVariable2CountBridge\nIfThenElse2ImplyBridge\nIfThenElse2ReificationBridge\nImply2ReificationBridge\nIncreasing2LPBridge\nInverse2ReificationBridge\nKnapsack2MILPBridge\nKnapsack2VariableCapacityKnapsackBridge\nValuedKnapsack2KnapsackBridge\nVariableCapacityKnapsack2MILPBridge\nVariableCapacityValuedKnapsack2VariableCapacityKnapsackBridge\nReificationLessThan2IndicatorBridge\nReificationLessThan2MILPBridge\nLexicographicallyGreaterThan2IndicatorBridge\nLexicographicallyLessThan2IndicatorBridge\nStrictlyDecreasing2LPBridge\nDoublyStrictlyLexicographicallyLessThan2StrictlyLexicographicallyGreaterThanBridge\nDoublyStrictlyLexicographicallyLessThan2StrictlyLexicographicallyLessThanBridge\nStrictlyIncreasing2LPBridge\nStrictlyLexicographicallyGreaterThan2IndicatorBridge\nStrictlyLexicographicallyLessThan2IndicatorBridge\nStrictly2LPBridge\nMaximumAmong2MILPBridge\nMinimumAmong2MILPBridge\nNonOverlappingOrthotopes2DisjunctionLPBridge\nNonOverlappingOrthotopes2ConditionallyNonOverlappingOrthotopesBridge\nSort2MILPBridge\nSort2SortPermutationBridge\nSortPermutation2AllDifferentBridge\nSlidingSum2LPBridge\nSymmetricAllDifferent2AllDifferentInverseBridge\nValuePrecedence2ReificationBridge\nVectorDomain2MILPBridge","category":"page"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.AbsoluteValue2MILPBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.AbsoluteValue2MILPBridge","text":"Bridges CP.AbsoluteValue to linear constraints and integer constraints.\n\nThe implemented model is the most generic one, so that the absolute value  always has a well-defined value. This requires the use of a binary variable. In many cases, this is not necessary, and simpler models could be used, but  checking this automatically would require access to the whole model.\n\nBased on Mosek's  modelling cookbook.\n\nYALMIP implements a similar formulation, with big-M and small-m values  computed based on the bounds for each variable.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.AllDifferent2DifferentFromBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.AllDifferent2DifferentFromBridge","text":"Bridges CP.AllDifferent to a series of CP.DifferentFrom.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.AllDifferentExceptConstants2ConjunctionDisjunctionBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.AllDifferentExceptConstants2ConjunctionDisjunctionBridge","text":"Bridges CP.AllDifferentExceptConstants to a series of CP.Disjunction of CP.DifferentFrom and CP.Domain.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.AllDifferentExceptConstants2ReificationBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.AllDifferentExceptConstants2ReificationBridge","text":"Bridges CP.AllDifferentExceptConstants to reifications.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.AllEqual2EqualToBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.AllEqual2EqualToBridge","text":"Bridges CP.AllEqual to a series of CP.EqualTo.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.ArgumentMaximumAmong2MILPBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.ArgumentMaximumAmong2MILPBridge","text":"Bridges CP.ArgumentMaximumAmong to MILP formulations, by the means of big-M  constraints.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.ArgumentMinimumAmong2MILPBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.ArgumentMinimumAmong2MILPBridge","text":"Bridges CP.ArgumentMinimumAmong to MILP formulations, by the means of big-M  constraints.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.BinPacking2MILPBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.BinPacking2MILPBridge","text":"Bridges CP.BinPacking to a MILP by creating binary variables for the bin  assignment and MILP constraints.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.FixedCapacityBinPacking2BinPackingBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.FixedCapacityBinPacking2BinPackingBridge","text":"Bridges CP.FixedCapacityBinPacking to CP.BinPacking by adding constraints  on the capacity variables.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.FixedCapacityBinPacking2VariableCapacityBinPackingBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.FixedCapacityBinPacking2VariableCapacityBinPackingBridge","text":"Bridges CP.FixedCapacityBinPacking to CP.VariableCapacityBinPacking by creating  capacity variables.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.VariableCapacityBinPacking2BinPackingBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.VariableCapacityBinPacking2BinPackingBridge","text":"Bridges CP.VariableCapacityBinPacking to CP.BinPacking by adding constraints  on the capacity variables.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.VariableCapacityBinPacking2MILPBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.VariableCapacityBinPacking2MILPBridge","text":"Bridges CP.BinPacking to a MILP by creating binary variables for the bin  assignment and MILP constraints.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.ClosedGlobalCardinality2GlobalCardinalityBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.ClosedGlobalCardinality2GlobalCardinalityBridge","text":"Bridges CP.ClosedGlobalCardinality to CP.GlobalCardinality.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.ClosedGlobalCardinalityVariable2GlobalCardinalityVariableBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.ClosedGlobalCardinalityVariable2GlobalCardinalityVariableBridge","text":"Bridges CP.ClosedGlobalCardinalityVariable to CP.GlobalCardinalityVariable.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.Conjunction2ReificationBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.Conjunction2ReificationBridge","text":"Bridges CP.Conjunction to reification.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.Count2ReificationBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.Count2ReificationBridge","text":"Bridges CP.Count to reification.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.CountCompare2CountBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.CountCompare2CountBridge","text":"Bridges CP.CountCompare to CP.Count.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.Decreasing2LPBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.Decreasing2LPBridge","text":"Bridges CP.Decreasing to linear constraints.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.DifferentFrom2PseudoMILPBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.DifferentFrom2PseudoMILPBridge","text":"Bridges CP.DifferentFrom to linear constraints (including, possibly, strict  inequalities). This constraint adds one variable to store the absolute value of the difference, and constrains it to be nonzero.\n\nFor AbstractFloat arguments (like Float64): equivalent to abs(x) > 0.0, i.e. a Strictly(GreaterThan(0.0)).\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.IndicatorDifferentFrom2PseudoMILPBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.IndicatorDifferentFrom2PseudoMILPBridge","text":"Bridges MOI.IndicatorSet{A, CP.DifferentFrom} to linear constraints  (including, possibly, strict inequalities). This constraint adds one variable to store the absolute value of the difference, and uses it for the indicator.\n\nFor AbstractFloat arguments (like Float64): equivalent to abs(x) > 0.0, i.e. a Strictly(GreaterThan(0.0)).\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.ReificationDifferentFrom2IndicatorBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.ReificationDifferentFrom2IndicatorBridge","text":"Bridges CP.Reification{CP.DifferentFrom} to indicator constraints, both with equality and inequalities (CP.DifferentFrom).\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.ReificationDifferentFrom2MILPBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.ReificationDifferentFrom2MILPBridge","text":"Bridges CP.Reification{CP.DifferentFrom} to MILP constraints.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.Disjunction2ReificationBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.Disjunction2ReificationBridge","text":"Bridges CP.Disjunction to reification.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.Domain2MILPBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.Domain2MILPBridge","text":"Bridges CP.Domain to MILP by adding one binary variable per possible  combination.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.DoublyLexicographicallyLessThan2LexicographicallyLessThanBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.DoublyLexicographicallyLessThan2LexicographicallyLessThanBridge","text":"Bridges CP.DoublyLexicographicallyLessThan to CP.LexicographicallyLessThan.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.DoublyLexicographicallyGreaterThan2LexicographicallyGreaterThanBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.DoublyLexicographicallyGreaterThan2LexicographicallyGreaterThanBridge","text":"Bridges CP.DoublyLexicographicallyGreaterThan to CP.LexicographicallyGreaterThan.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.Element2MILPBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.Element2MILPBridge","text":"Bridges CP.Element to MILP constraints by using a unary encoding of the  index in the array.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.ElementVariableArray2MILPBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.ElementVariableArray2MILPBridge","text":"Bridges CP.ElementVariableArray to MILP constraints by using a unary  encoding of the index in the array.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.ReificationEqualTo2IndicatorBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.ReificationEqualTo2IndicatorBridge","text":"Bridges CP.Reification{MOI.EqualTo} to indicator constraints, both with equality and inequalities (CP.DifferentFrom).\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.ReificationEqualTo2MILPBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.ReificationEqualTo2MILPBridge","text":"Bridges CP.Reification{MOI.EqualTo} to MILP constraints.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.ReificationGreaterThan2IndicatorBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.ReificationGreaterThan2IndicatorBridge","text":"Bridges CP.Reification{MOI.GreaterThan} to indicator constraints with (strict)  inequalities.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.ReificationGreaterThan2MILPBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.ReificationGreaterThan2MILPBridge","text":"Bridges CP.Reification{MOI.GreaterThan} to MILP constraints.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.GlobalCardinality2CountBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.GlobalCardinality2CountBridge","text":"Bridges CP.GlobalCardinality to CP.Count.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.GlobalCardinality2GlobalCardinalityVariableBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.GlobalCardinality2GlobalCardinalityVariableBridge","text":"Bridges CP.GlobalCardinality to CP.GlobalCardinalityVariable.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.GlobalCardinalityVariable2CountBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.GlobalCardinalityVariable2CountBridge","text":"Bridges CP.GlobalCardinalityVariable to CP.Count.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.IfThenElse2ImplyBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.IfThenElse2ImplyBridge","text":"Bridges CP.IfThenElse to CP.Imply.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.IfThenElse2ReificationBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.IfThenElse2ReificationBridge","text":"Bridges CP.IfThenElse to reification.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.Imply2ReificationBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.Imply2ReificationBridge","text":"Bridges CP.Imply to reification.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.Increasing2LPBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.Increasing2LPBridge","text":"Bridges CP.Increasing to linear constraints.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.Inverse2ReificationBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.Inverse2ReificationBridge","text":"Bridges CP.Inverse to reification.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.Knapsack2MILPBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.Knapsack2MILPBridge","text":"Bridges CP.Knapsack to a MILP by adding the corresponding MILP constraint.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.Knapsack2VariableCapacityKnapsackBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.Knapsack2VariableCapacityKnapsackBridge","text":"Bridges CP.Knapsack to CP.VariableCapacityKnapsack by creating  capacity variables.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.ValuedKnapsack2KnapsackBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.ValuedKnapsack2KnapsackBridge","text":"Bridges CP.ValuedKnapsack to CP.Knapsack by creating a value constraint.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.VariableCapacityKnapsack2MILPBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.VariableCapacityKnapsack2MILPBridge","text":"Bridges CP.VariableCapacityKnapsack to a MILP by adding the corresponding  MILP constraint.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.VariableCapacityValuedKnapsack2VariableCapacityKnapsackBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.VariableCapacityValuedKnapsack2VariableCapacityKnapsackBridge","text":"Bridges CP.VariableCapacityValuedKnapsack to CP.VariableCapacityKnapsack  by creating a value constraint.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.ReificationLessThan2IndicatorBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.ReificationLessThan2IndicatorBridge","text":"Bridges CP.Reification{MOI.LessThan} to indicator constraints with (strict)  inequalities.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.ReificationLessThan2MILPBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.ReificationLessThan2MILPBridge","text":"Bridges CP.Reification{MOI.LessThan} to MILP constraints.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.LexicographicallyGreaterThan2IndicatorBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.LexicographicallyGreaterThan2IndicatorBridge","text":"Bridges CP.LexicographicallyGreaterThan to indicators.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.LexicographicallyLessThan2IndicatorBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.LexicographicallyLessThan2IndicatorBridge","text":"Bridges CP.LexicographicallyLessThan to indicators.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.StrictlyDecreasing2LPBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.StrictlyDecreasing2LPBridge","text":"Bridges CP.Strictly{CP.Decreasing} to linear constraints.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.DoublyStrictlyLexicographicallyLessThan2StrictlyLexicographicallyGreaterThanBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.DoublyStrictlyLexicographicallyLessThan2StrictlyLexicographicallyGreaterThanBridge","text":"Bridges CP.Strictly{CP.DoublyLexicographicallyGreaterThan}  to CP.Strictly{CP.LexicographicallyGreaterThan}.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.DoublyStrictlyLexicographicallyLessThan2StrictlyLexicographicallyLessThanBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.DoublyStrictlyLexicographicallyLessThan2StrictlyLexicographicallyLessThanBridge","text":"Bridges CP.Strictly{CP.DoublyLexicographicallyLessThan} to  CP.Strictly{CP.LexicographicallyLessThan}.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.StrictlyIncreasing2LPBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.StrictlyIncreasing2LPBridge","text":"Bridges CP.Strictly{CP.Increasing} to linear constraints.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.StrictlyLexicographicallyGreaterThan2IndicatorBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.StrictlyLexicographicallyGreaterThan2IndicatorBridge","text":"Bridges CP.Strictly{CP.LexicographicallyGreaterThan} to indicators.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.StrictlyLexicographicallyLessThan2IndicatorBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.StrictlyLexicographicallyLessThan2IndicatorBridge","text":"Bridges CP.Strictly{CP.LexicographicallyLessThan} to indicators.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.Strictly2LPBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.Strictly2LPBridge","text":"Bridges CP.Strictly to linear constraints.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.MaximumAmong2MILPBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.MaximumAmong2MILPBridge","text":"Bridges CP.MaximumAmong to MILP formulations, by the means of big-M  constraints.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.MinimumAmong2MILPBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.MinimumAmong2MILPBridge","text":"Bridges CP.MinimumAmong to MILP formulations, by the means of big-M  constraints.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.NonOverlappingOrthotopes2DisjunctionLPBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.NonOverlappingOrthotopes2DisjunctionLPBridge","text":"Bridges CP.NonOverlappingOrthotopes to CP.Disjunction of linear  inequations (MOI.LessThan{T}).\n\nVariable number of constraints in the disjunction (two per dimension).\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.NonOverlappingOrthotopes2ConditionallyNonOverlappingOrthotopesBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.NonOverlappingOrthotopes2ConditionallyNonOverlappingOrthotopesBridge","text":"Bridges CP.NonOverlappingOrthotopes to  CP.ConditionallyNonOverlappingOrthotopes.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.Sort2MILPBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.Sort2MILPBridge","text":"Bridges CP.Sort to MILP constraints by adding O(n²) binary variables, with a  transportation-like model.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.Sort2SortPermutationBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.Sort2SortPermutationBridge","text":"Bridges CP.Sort to CP.SortPermutation by adding index variables.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.SortPermutation2AllDifferentBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.SortPermutation2AllDifferentBridge","text":"Bridges CP.SortPermutation to CP.AllDifferent and  CP.ElementVariableArray.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.SlidingSum2LPBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.SlidingSum2LPBridge","text":"Bridges CP.SlidingSum to linear constraints.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.SymmetricAllDifferent2AllDifferentInverseBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.SymmetricAllDifferent2AllDifferentInverseBridge","text":"Bridges CP.SymmetricAllDifferent to CP.AllDifferent and CP.Inverse.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.ValuePrecedence2ReificationBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.ValuePrecedence2ReificationBridge","text":"Bridges CP.ValuePrecedence to reification.\n\n\n\n\n\n","category":"type"},{"location":"reference/bridges_sets/#ConstraintProgrammingExtensions.Bridges.VectorDomain2MILPBridge","page":"Set bridges","title":"ConstraintProgrammingExtensions.Bridges.VectorDomain2MILPBridge","text":"Bridges CP.VectorDomain to MILP by adding one binary variable per  possible combination.\n\n\n\n\n\n","category":"type"},{"location":"#ConstraintProgrammingExtensions.jl","page":"Introduction","title":"ConstraintProgrammingExtensions.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This package provides extensions to  MathOptInterface in order to support constraint programming. This allows to use the same user model with several solvers. ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"On top of providing a uniform interface, this package also implements a  quantity of bridges, i.e. reformulations of constraints, to bridge the gap when a solver does not support a specific constraint. In particular, the set  of bridges should make it possible to transform any CP model into a MIP model.","category":"page"},{"location":"#Citing-ConstraintProgrammingExtensions","page":"Introduction","title":"Citing ConstraintProgrammingExtensions","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Currently, there is no article or preprint that can be cited for CPE.  However, you can use the Zenodo DOI: ","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"@software{thibaut_cuvelier_2021_5122859,\n  author       = {Thibaut Cuvelier and\n                  Oscar Dowson},\n  title        = {{dourouc05/ConstraintProgrammingExtensions.jl: \n                   v0.3.0}},\n  month        = jul,\n  year         = 2021,\n  publisher    = {Zenodo},\n  version      = {v0.3.0},\n  doi          = {10.5281/zenodo.5122859},\n  url          = {https://doi.org/10.5281/zenodo.5122859}\n}","category":"page"},{"location":"reference/sets/","page":"Sets","title":"Sets","text":"CurrentModule = ConstraintProgrammingExtensions","category":"page"},{"location":"reference/sets/#sets_ref","page":"Sets","title":"Sets","text":"","category":"section"},{"location":"reference/sets/#Generic-CP-sets","page":"Sets","title":"Generic CP sets","text":"","category":"section"},{"location":"reference/sets/#Domain-of-variables","page":"Sets","title":"Domain of variables","text":"","category":"section"},{"location":"reference/sets/","page":"Sets","title":"Sets","text":"Domain\nVectorDomain\nAntiDomain\nVectorAntiDomain\nMembership","category":"page"},{"location":"reference/sets/#ConstraintProgrammingExtensions.Domain","page":"Sets","title":"ConstraintProgrammingExtensions.Domain","text":"Domain{T <: Number}(values::Set{T})\n\nThe set corresponding to an enumeration of constant values.\n\nThe value of a scalar function is enforced to take a value from this set of values.\n\nThis constraint is sometimes called in, member or allowed_assignments. https://sofdem.github.io/gccat/gccat/Cdomain.html\n\nExample\n\nx in Domain(1:3)\n# enforces `x == 1` OR `x == 2` OR `x == 3`.\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.VectorDomain","page":"Sets","title":"ConstraintProgrammingExtensions.VectorDomain","text":"VectorDomain{T <: Number}(dimension::Int, values::Set{Vector{T}})\n\nThe set corresponding to an enumeration of constant values.\n\nThe value of a vector function is enforced to take a value from this set of vector values.\n\nThis constraint is sometimes called in, member or allowed_assignments. https://sofdem.github.io/gccat/gccat/Cdomain.html\n\nExample\n\n[x, y] in Domain(2, Set([[1, 2], [2, 3]]))\n# enforces (`x == 1` AND `y == 2`) OR (`x == 2` AND `y == 3`).\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.AntiDomain","page":"Sets","title":"ConstraintProgrammingExtensions.AntiDomain","text":"AntiDomain{T <: Number}(values::Set{T})\n\nThe set corresponding to an enumeration of constant values that are excluded.\n\nThe value of a scalar function is enforced to take a value that is not from  this set of values.\n\nThis constraint is sometimes called (not_in)[https://sofdem.github.io/gccat/gccat/Cnotin.html], `notmember,rel,forbiddenassignments, ornogood`.\n\nExample\n\nx in AntiDomain(1:3)\n# enforces `x != 1` AND `x != 2` AND `x != 3`.\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.VectorAntiDomain","page":"Sets","title":"ConstraintProgrammingExtensions.VectorAntiDomain","text":"VectorAntiDomain{T <: Number}(values::Set{T})\n\nThe set corresponding to an enumeration of constant values that are excluded.\n\nThe value of a vector function is enforced to take a value that is not from  this set of vector values.\n\nThis constraint is sometimes called (not_in)[https://sofdem.github.io/gccat/gccat/Cnotin.html], `notmember,rel,forbiddenassignments, ornogood`.\n\nExample\n\n[x, y] in VectorAntiDomain(2, Set([[1, 2], [2, 3]]))\n# enforces (`x != 1` AND `y != 2`) OR (`x != 2` AND `y != 3`).\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.Membership","page":"Sets","title":"ConstraintProgrammingExtensions.Membership","text":"Membership(dimension)\n\nThe first element of a function of dimension dimension must equal at least one of the following dimension - 1 elements of the function.\n\nThis constraint is sometimes called in_set.\n\nExample\n\n[x, y, z] in Membership(3)\n# enforces `x == y` OR `x == z`.\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#Array-indexing","page":"Sets","title":"Array indexing","text":"","category":"section"},{"location":"reference/sets/","page":"Sets","title":"Sets","text":"Element\nElementVariableArray","category":"page"},{"location":"reference/sets/#ConstraintProgrammingExtensions.Element","page":"Sets","title":"ConstraintProgrammingExtensions.Element","text":"Element{T <: Real}(values::Vector{T})\n\n(x i) in mathbbR times mathbbN  x = valuesi\n\nLess formally, the first element constrained in this set will take the value of values at the index given by the second element.\n\nAlso called indexing  or nth.\n\nExamples\n\n[x, 3] in Element([4, 5, 6])\n# Enforces that x = 6, because 6 is the 3rd element from the array.\n\n[y, j] in Element([4, 5, 6])\n# Enforces that y = array[j], depending on the value of j (an integer\n# between 1 and 3).\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.ElementVariableArray","page":"Sets","title":"ConstraintProgrammingExtensions.ElementVariableArray","text":"ElementVariableArray(dimension::Int)\n\n(x i values) in mathbbR times mathbbN times mathbbR^mathttdimension  x = valuesi\n\nLess formally, the first element constrained in this set will take the value of values at the index given by the second element in the array given by the  remaining elements constrained in the set.\n\nExamples\n\n[x, 3, a, b, c] in ElementVariableArray(3)\n# Enforces that x = c, because 6 is the 3rd element from the array [a, b, c].\n\n[y, j, a, b, c] in ElementVariableArray(3)\n# Enforces that y = array[j], depending on the value of j (an integer\n# between 1 and 3), from the array [a, b, c].\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#Others","page":"Sets","title":"Others","text":"","category":"section"},{"location":"reference/sets/","page":"Sets","title":"Sets","text":"AllEqual\nAllDifferent\nAllDifferentExceptConstants\nAllDifferentExceptConstant\nSymmetricAllDifferent\nDifferentFrom\nMinimumDistance\nMaximumDistance\nInverse\nSlidingSum\nValuePrecedence","category":"page"},{"location":"reference/sets/#ConstraintProgrammingExtensions.AllEqual","page":"Sets","title":"ConstraintProgrammingExtensions.AllEqual","text":"AllEqual(dimension::Int)\n\nThe set corresponding to an all-equal constraint.\n\nAll expressions of a vector-valued function are enforced to take the same value in the solution.\n\nExample\n\n[x, y, z] in AllEqual(3)\n# enforces `x == y` AND `x == z`.\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.AllDifferent","page":"Sets","title":"ConstraintProgrammingExtensions.AllDifferent","text":"AllDifferent(dimension::Int)\n\nThe set corresponding to an all-different constraint.\n\nAll expressions of a vector-valued function are enforced to take distinct values in the solution: for all pairs of expressions, their values must differ.\n\nThis constraint is sometimes called distinct.\n\nExample\n\n[x, y, z] in AllDifferent(3)\n# enforces `x != y` AND `x != z` AND `y != z`.\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.AllDifferentExceptConstants","page":"Sets","title":"ConstraintProgrammingExtensions.AllDifferentExceptConstants","text":"AllDifferentExceptConstants{T <: Number}(dimension::Int, k::Set{T})\n\nAll expressions of a vector-valued function are enforced to take distinct values in the solution, but values equal to any value in k are not  considered: for all pairs of expressions, either their values must differ or at least one of the two variables has a value in k.\n\nThis constraint is sometimes called distinct.\n\nExample\n\n[x, y] in AllDifferentExceptConstant(2, 0)\n# enforces `x != y` OR `x == 0` OR `y == 0`.\n\n[x, y] in AllDifferentExceptConstant(2, Set([0, 1]))\n# enforces `x != y` OR `x == 0` OR `y == 0` OR `x == 1` OR `y == 1`.\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.AllDifferentExceptConstant","page":"Sets","title":"ConstraintProgrammingExtensions.AllDifferentExceptConstant","text":"Special case of AllDifferentExceptConstants where only one value is  ignored.\n\n\n\n\n\n","category":"function"},{"location":"reference/sets/#ConstraintProgrammingExtensions.SymmetricAllDifferent","page":"Sets","title":"ConstraintProgrammingExtensions.SymmetricAllDifferent","text":"SymmetricAllDifferent(dimension::Int)\n\nThe set corresponding to an all-different constraint, with the additional  requirement that the array must be symmetric.\n\nAll expressions of a vector-valued function are enforced to take distinct values in the solution: for all pairs of expressions, their values must differ. Symmetry means that, if xi=j, then xj=i.\n\nThis constraint is sometimes called symmetric_alldifferent.\n\nExample\n\n[x, y, z] in SymmetricAllDifferent(3)\n# enforces `x != y` AND `x != z` AND `y != z` AND `(x == 2 => y == 1)` AND \n# `(x == 3 => z = 1)` AND `(y == 1 => x == 2)` AND `(y == 3 => z == 2)` AND \n# `(z == 1 => x == 3)` AND `(z == 2 => y == 3)`.\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.DifferentFrom","page":"Sets","title":"ConstraintProgrammingExtensions.DifferentFrom","text":"DifferentFrom{T <: Number}(value::T)\n\nThe set excluding the single point x in mathbbR where x is given by value.\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.MinimumDistance","page":"Sets","title":"ConstraintProgrammingExtensions.MinimumDistance","text":"MinimumDistance{T <: Real}(dimension::Int, k::T)\n\nEnsures that all the dimension expressions in this set are at least k  apart, in absolute value:\n\nBigx in mathbbS^mathttdimension Big x_i - x_j geq k forall i neq j in 1 2dots mathttdimension Big\n\nAlso called all_min_dist  or inter_distance.\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.MaximumDistance","page":"Sets","title":"ConstraintProgrammingExtensions.MaximumDistance","text":"MaximumDistance{T <: Real}(dimension::Int, k::T)\n\nEnsures that all the dimension expressions in this set are at most k  apart, in absolute value:\n\nBigx in mathbbS^mathttdimension Big x_i - x_j leq k forall i neq j in 1 2dots mathttdimension Big\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.Inverse","page":"Sets","title":"ConstraintProgrammingExtensions.Inverse","text":"Inverse(dimension::Int)\n\nEnsures that the two arrays of variables of size dimension are the inverse  one of the other. \n\nBig(x y) in mathbbR^mathttdimension times mathbbR^dimension Big x_i = j iff y_j = i forall i j in 1 2 dots mathttdimension Big\n\nIndices start at 1, like Julia.\n\nAlso called channel,  inverse_channeling, or assignment.\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.SlidingSum","page":"Sets","title":"ConstraintProgrammingExtensions.SlidingSum","text":"SlidingSum{T}(low::T, high::T, length::Int, dimension::Int)\n\nEnsures that the sum of all sequences of size length have a value between low and high. \n\nx in mathbbR^mathttdimension  mathttlow leq sum_j=i^i+mathttlength-1 x_i leq mathtthigh forall i in  0 1 dots mathttdimension - mathttlength  \n\nhttps://sofdem.github.io/gccat/gccat/Csliding_sum.html\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.ValuePrecedence","page":"Sets","title":"ConstraintProgrammingExtensions.ValuePrecedence","text":"ValuePrecedence(before::T, value::T, dimension::Int)\n\nEnsures that the value before happens before value in the array of size  dimension. \n\nx in mathbbR^mathttdimension  exists i  j x_i = mathttbefore x_j = mathttvalue \n\nAlso called precede or value_precede.\n\nhttps://sofdem.github.io/gccat/gccat/Cintvalueprecede.html\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#Combinatorial-constraints","page":"Sets","title":"Combinatorial constraints","text":"","category":"section"},{"location":"reference/sets/#Bin-packing","page":"Sets","title":"Bin packing","text":"","category":"section"},{"location":"reference/sets/","page":"Sets","title":"Sets","text":"BinPacking\nFixedCapacityBinPacking\nVariableCapacityBinPacking","category":"page"},{"location":"reference/sets/#ConstraintProgrammingExtensions.BinPacking","page":"Sets","title":"ConstraintProgrammingExtensions.BinPacking","text":"BinPacking(n_bins::Int, n_items::Int, weights::Vector{T})\n\nImplements an uncapacitated version of the bin-packing problem.\n\nThe first n_bins variables give the load in each bin, the last n_items give the number of the bin to which the item is assigned to. \n\nThe load of a bin is defined as the sum of the sizes of the items put in that  bin.\n\nAlso called pack.\n\nExample\n\n[a, b, c] in BinPacking{Int}(1, 2, [2, 3])\n# As there is only one bin, the only solution is to put all the items in \n# that bin.\n# Enforces that:\n# - the bin load is the sum of the weights of the objects in that bin: \n#   a = 2 + 3\n# - the bin number of the two items is 1: b = c = 1\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.FixedCapacityBinPacking","page":"Sets","title":"ConstraintProgrammingExtensions.FixedCapacityBinPacking","text":"FixedCapacityBinPacking(n_bins::Int, n_items::Int, weights::Vector{T}, capacities::Vector{<:Real})\n\nImplements a capacitated version of the bin-packing problem where capacities are constant.\n\nThe first n_bins variables give the load in each bin, the last n_items  give the number of the bin to which the item is assigned to. \n\nThe load of a bin is defined as the sum of the sizes of the items put in that  bin.\n\nThis constraint is equivalent to BinPacking with inequality constraints on  the loads of the bins where the upper bound is a constant. However, there are  more efficient propagators for the combined constraint (bin packing with  maximum load); if such propagators are not available, bridges are available to make the conversion seamless.\n\nAlso called bin_packing_capa.\n\nExample\n\n[a, b, c] in FixedCapacityBinPacking{Int}(1, 2, [2, 3], [4])\n# As there is only one bin, the only solution is to put all the items in\n# that bin if its capacity is large enough.\n# Enforces that:\n# - the bin load is the sum of the weights of the objects in that bin: \n#   a = 2 + 3\n# - the bin load is at most its capacity: a <= 4 (given in the set)\n# - the bin number of the two items is 1: b = c = 1\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.VariableCapacityBinPacking","page":"Sets","title":"ConstraintProgrammingExtensions.VariableCapacityBinPacking","text":"VariableCapacityBinPacking(n_bins::Int, n_items::Int, weights::Vector{T})\n\nImplements an capacitated version of the bin-packing problem where capacities  are optimisation variables.\n\nThe first n_bins variables give the load in each bin, the next n_bins are the capacity of each bin, the last n_items give the number of the bin to which the item is assigned to.\n\nThe load of a bin is defined as the sum of the sizes of the items put in that  bin.\n\nThis constraint is equivalent to BinPacking with inequality constraints on  the loads of the bins where the upper bound is any expression. However, there  are more efficient propagators for the combined constraint (bin packing with  maximum load) and for the fixed-capacity version.\n\nAlso called bin_packing_capa.\n\nExample\n\n[a, 2, b, c] in VariableCapacityBinPacking(1, 2, [2, 3])\n# As there is only one bin, the only solution is to put all the items in\n# that bin if its capacity is large enough.\n# Enforces that:\n# - the bin load is the sum of the weights of the objects in that bin: \n#   a = 2 + 3\n# - the bin load is at most its capacity: a <= 2 (given in a variable)\n# - the bin number of the two items is 1: b = c = 1\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#Knapsack","page":"Sets","title":"Knapsack","text":"","category":"section"},{"location":"reference/sets/","page":"Sets","title":"Sets","text":"Knapsack\nVariableCapacityKnapsack\nValuedKnapsack\nVariableCapacityValuedKnapsack","category":"page"},{"location":"reference/sets/#ConstraintProgrammingExtensions.Knapsack","page":"Sets","title":"ConstraintProgrammingExtensions.Knapsack","text":"Knapsack{T <: Real}(weights::T, capacity::Vector{T})\n\nEnsures that the n variables respect a knapsack constraint with fixed weights and a fixed capacity: \n\nx in 0 1^n  sum_i=1^n mathttweightsi x_i leq mathttcapacity .\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.VariableCapacityKnapsack","page":"Sets","title":"ConstraintProgrammingExtensions.VariableCapacityKnapsack","text":"VariableCapacityKnapsack{T <: Real}(weights::Vector{T})\n\nEnsures that the first n variables respect a knapsack constraint with fixed weights and a capacity given by the last variable: \n\n(x y) in 0 1^n times mathbbR  sum_i=1^n mathttweightsi x_i leq y .\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.ValuedKnapsack","page":"Sets","title":"ConstraintProgrammingExtensions.ValuedKnapsack","text":"ValuedKnapsack{T <: Real}(weights::T, capacity::Vector{T})\n\nEnsures that the n first variables respect a knapsack constraint with fixed  weights and a fixed capacity, the last variable being the total value of the  knapsack: \n\n(x y) in 0 1^n times mathbbR  sum_i=1^n mathttweightsi x_i leq mathttcapacity land y = sum_i=1^n mathttvaluesi x_i .\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.VariableCapacityValuedKnapsack","page":"Sets","title":"ConstraintProgrammingExtensions.VariableCapacityValuedKnapsack","text":"VariableCapacityValuedKnapsack{T <: Real}(weights::Vector{T})\n\nEnsures that the first n variables respect a knapsack constraint with  fixed weights and a capacity given by the last-but-one variable; the total  value is the last variable: \n\n(x y z) in 0 1^n times mathbbR times mathbbR  sum_i=1^n mathttweightsi x_i leq y land z = sum_i=1^n mathttvaluesi x_i .\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#Others-2","page":"Sets","title":"Others","text":"","category":"section"},{"location":"reference/sets/","page":"Sets","title":"Sets","text":"Contiguity","category":"page"},{"location":"reference/sets/#ConstraintProgrammingExtensions.Contiguity","page":"Sets","title":"ConstraintProgrammingExtensions.Contiguity","text":"Contiguity(dimension::Int)\n\nEnsures that, in the binary variables x constrained to be in this set,  all the 1s are contiguous. The vector must correspond to the regular expression 0*1*0*.\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#Counting-constraints","page":"Sets","title":"Counting constraints","text":"","category":"section"},{"location":"reference/sets/","page":"Sets","title":"Sets","text":"Count\nGlobalCardinality\nGlobalCardinalityVariable\nClosedGlobalCardinality\nClosedGlobalCardinalityVariable\nCountCompare\nCountDistinct","category":"page"},{"location":"reference/sets/#ConstraintProgrammingExtensions.Count","page":"Sets","title":"ConstraintProgrammingExtensions.Count","text":"Count{S <: MOI.AbstractScalarSet}(dimension::Int, set::MOI.AbstractScalarSet)\n\n(y x) in mathbbN times mathbbT^mathttdimension  y = i  x_i in S \n\ndimension is the number of variables that are checked against the set.\n\nAlso called among.\n\nExample\n\n[w, x, y, z] in Count(3, MOI.EqualTo(2.0))\n# w == sum([x, y, z] .== 2.0)\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.GlobalCardinality","page":"Sets","title":"ConstraintProgrammingExtensions.GlobalCardinality","text":"GlobalCardinality{T}(dimension::Int, values::Vector{T})\n\n(x y) in mathbbT^mathttdimension times mathbbN^d  y_i =  j  x_j = mathttvalues_i forall j  \n\nThe first dimension variables are an array, the last variables are the  number of times that each item of values is present in the first array. Values that are not in values are ignored. \n\nAlso called gcc or count.\n\nExample\n\n[x, y, z, v, w] in GlobalCardinality(3, [2.0, 4.0])\n# v == sum([x, y, z] .== 2.0)\n# w == sum([x, y, z] .== 4.0)\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.GlobalCardinalityVariable","page":"Sets","title":"ConstraintProgrammingExtensions.GlobalCardinalityVariable","text":"GlobalCardinalityVariable(dimension::Int, n_values::Int)\n\n(x y z) in mathbbT^mathttdimension times mathbbN^mathttn_values times mathbbT^mathttn_values  y_i =  j  x_j = z_i forall j  \n\nThe first dimension variables are an array, the next n_values variables  are the number of times that each item of the last n_values variables is  present in the first array. Values of the first array that are not in the  n_values are ignored. \n\nAlso called distribute.\n\nExample\n\n[x, y, z, t, u, v, w] in GlobalCardinalityVariable(3, 2)\n# t == sum([x, y, z] .== v)\n# u == sum([x, y, z] .== w)\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.ClosedGlobalCardinality","page":"Sets","title":"ConstraintProgrammingExtensions.ClosedGlobalCardinality","text":"ClosedGlobalCardinality{T}(dimension::Int, values::Vector{T})\n\n(x y) in mathbbT^mathttdimension times mathbbN^d  y_i =  j  x_j = mathttvalues_i forall j  \n\nThe first dimension variables are an array, the last variables are the  number of times that each item of values is present in the first array. Each value of the first array must be within values.\n\nExample\n\n[x, y, z, v, w] in ClosedGlobalCardinality(3, [2.0, 4.0])\n# v == sum([x, y, z] .== 2.0)\n# w == sum([x, y, z] .== 4.0)\n# x ∈ [2.0, 4.0], y ∈ [2.0, 4.0], z ∈ [2.0, 4.0]\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.ClosedGlobalCardinalityVariable","page":"Sets","title":"ConstraintProgrammingExtensions.ClosedGlobalCardinalityVariable","text":"ClosedGlobalCardinalityVariable(dimension::Int, n_values::Int)\n\n(x y z) in mathbbT^mathttdimension times mathbbN^mathttn_values times mathbbT^mathttn_values  y_i =  j  x_j = z_i forall j  \n\nThe first dimension variables are an array, the next n_values variables  are the number of times that each item of the last n_values variables is  present in the first array. Each value of the first array must be within the  next given n_values.\n\nAlso called distribute.\n\nExample\n\n[x, y, z, t, u, v, w] in ClosedGlobalCardinalityVariable(3, 2)\n# t == sum([x, y, z] .== v)\n# u == sum([x, y, z] .== w)\n# x ∈ [v, w], y ∈ [v, w], z ∈ [v, w]\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.CountCompare","page":"Sets","title":"ConstraintProgrammingExtensions.CountCompare","text":"CountCompare(dimension::Int)\n\n(z x y) in mathbbN times mathbbR^mathttdimension times mathbbR^mathttdimension  Z = i  x_i = y_i\n\nThe first dimension variables are the first array that is compared to the  second one, indicated by the next dimension variables. The last variable is the number of values that are identical in both arrays.\n\nExample\n\n[v, w, x, y, z] in Count(2)\n# w == sum([w, x] .== [y, z])\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.CountDistinct","page":"Sets","title":"ConstraintProgrammingExtensions.CountDistinct","text":"CountDistinct(dimension::Int)\n\nThe first variable in the set is forced to be the number of distinct values in the rest of the expressions.\n\nThis is a relaxed version of AllDifferent; it encodes an AllDifferent constraint when the first variable is the number of variables in the set.\n\nAlso called nvalues.\n\nExample\n\n[x, y, z] in CountDistinct(3)\n# x = 1 if y == z, x = 2 if y != z\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#Graph-constraints","page":"Sets","title":"Graph constraints","text":"","category":"section"},{"location":"reference/sets/","page":"Sets","title":"Sets","text":"Circuit\nCircuitPath\nWeightedCircuit\nWeightedCircuitPath","category":"page"},{"location":"reference/sets/#ConstraintProgrammingExtensions.Circuit","page":"Sets","title":"ConstraintProgrammingExtensions.Circuit","text":"Circuit(n_nodes::Int)\n\nA Hamiltonian circuit. If the vector x is constrained within a Circuit(n), each x[i] denotes the next node in the graph, for i ∈ [1, n]. \n\nThe considered graph is an undirected complete graph with n nodes.\n\nAlso called cycle or atour.\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.CircuitPath","page":"Sets","title":"ConstraintProgrammingExtensions.CircuitPath","text":"CircuitPath(n_nodes::Int)\n\nA Hamiltonian circuit. If the vectors x and y are constrained within a  CircuitPath(n), each x[i] denotes the next node in the graph, for  i ∈ [1, n]. The last n variables denote the order in which the nodes are visited, i.e. y[1] is the first visited node (1 by convention), y[2] is  the next node in the path, etc.\n\nThe considered graph is an undirected complete graph with n nodes.\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.WeightedCircuit","page":"Sets","title":"ConstraintProgrammingExtensions.WeightedCircuit","text":"WeightedCircuit{T <: Real}(n_nodes::Int, cost_matrix::AbstractMatrix{T})\n\nA Hamiltonian circuit. If the vector x and the scalar c are constrained within a WeightedCircuit(n, cost_matrix), each x[i] denotes the next node  in the graph, for i ∈ [1, n]. c is the total cost of the circuit, defined as: \n\nc = sum_i=1^n mathttcost_matrix_i xi\n\nThe considered graph is an undirected complete graph with n nodes.\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.WeightedCircuitPath","page":"Sets","title":"ConstraintProgrammingExtensions.WeightedCircuitPath","text":"WeightedCircuitPath(n_nodes::Int, cost_matrix::AbstractMatrix{T})\n\nA Hamiltonian circuit. If the vectors x and y and the scalar c are  constrained within a CircuitPath(n), each x[i] denotes the next node in the graph, for  i ∈ [1, n]. The next n variables denote the order in which the nodes are visited, i.e. y[1] is the first visited node (1 by convention), y[2] is  the next node in the path, etc. c is the total cost of the circuit, defined as: \n\nc = sum_i=1^n mathttcost_matrix_i xi\n\nThe considered graph is an undirected complete graph with n nodes.\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#Reification-constraints","page":"Sets","title":"Reification constraints","text":"","category":"section"},{"location":"reference/sets/","page":"Sets","title":"Sets","text":"Reification\nEquivalence\nEquivalenceNot\nIfThenElse\nImply\nConjunction\nDisjunction\nNegation\nTrue\nFalse","category":"page"},{"location":"reference/sets/#ConstraintProgrammingExtensions.Reification","page":"Sets","title":"ConstraintProgrammingExtensions.Reification","text":"Reification{S <: MOI.AbstractSet}(set::S)\n\n(y x) in 0 1 times mathbbR^n  y = 1 iff x in set y = 0 otherwise.\n\nThis set serves to find out whether a given constraint is satisfied.\n\nThe only possible values are 0 and 1 for the first variable of the set.\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.Equivalence","page":"Sets","title":"ConstraintProgrammingExtensions.Equivalence","text":"Equivalence{S1 <: MOI.AbstractSet, S2 <: MOI.AbstractSet}(set1::S1, \n                                                          set2::S2)\n\nThe logical equivalence operator ≡ or ⇔.\n\n(x y) in mathbbR^a+b  x in S1 iff y in S2.\n\nThe two constraints must be either satisfied or not satisfied at the same time. More explicitly, if the first one is satisfied, then the second one is implied to be satisfied too; if the second one is satisfied, then the first one is  implied.\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.EquivalenceNot","page":"Sets","title":"ConstraintProgrammingExtensions.EquivalenceNot","text":"EquivalenceNot{S1 <: MOI.AbstractSet, S2 <: MOI.AbstractSet}(set1::S1,                                                                  set2::S2)\n\nThe logical equivalence operator ≡ or ⇔, with the second argument negated.\n\n(x y) in mathbbR^a+b  x in S1 iff y notin S2.\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.IfThenElse","page":"Sets","title":"ConstraintProgrammingExtensions.IfThenElse","text":"IfThenElse{\n    Condition <: MOI.AbstractSet, \n    TrueConstraint <: MOI.AbstractSet, \n    FalseConstraint <: MOI.AbstractSet\n}(condition::Condition, true_constraint::TrueConstraint, \n  false_constraint::FalseConstraint)\n\nThe ternary operator.\n\nIf the condition is satisfied, then the first constraint (of type  TrueConstraint) will be implied. Otherwise, the second constraint (of type FalseConstraint) will be implied.\n\n(x y z) in mathbbR^(a+b+c)  y in TrueConstraint iff x in set z in FalseConstraint otherwise.\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.Imply","page":"Sets","title":"ConstraintProgrammingExtensions.Imply","text":"Imply{\n    Antecedent <: MOI.AbstractSet,\n    Consequent <: MOI.AbstractSet\n}(antecedent::Antecedent, consequent::Consequent)\n\nThe logical implication operator ⇒.\n\nIf the antecedent is satisfied, then the consequent will be implied to be  satisfied. Otherwise, nothing is implied on the truth value of consequent.\n\n(x y) in mathbbR^a times mathbbR^b  y in Consequent if x in Antecedent.\n\nAlso called if_then, material implication, or material conditional.\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.Conjunction","page":"Sets","title":"ConstraintProgrammingExtensions.Conjunction","text":"Conjunction{Ts}(constraints::Ts)\n\nThe logical conjunction operator ∧ (AND).\n\n(x ydots) in mathbbR^a times mathbbR^bdots  x in mathbbS_1 land y in mathbbS_2 dots .\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.Disjunction","page":"Sets","title":"ConstraintProgrammingExtensions.Disjunction","text":"Disjunction{Ts}(constraints::Ts)\n\nThe logical disjunction operator ∨ (AND).\n\n(x ydots) in mathbbR^a times mathbbR^bdots  x in mathbbS_1 lor y in mathbbS_2 dots .\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.Negation","page":"Sets","title":"ConstraintProgrammingExtensions.Negation","text":"Negation{S <: MOI.AbstractSet}(set::S)\n\nThe logical negation operator ¬ (NOT).\n\nx in times mathbbR^n  x notin set.\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.True","page":"Sets","title":"ConstraintProgrammingExtensions.True","text":"True()\n\nA constraint that is always true. \n\nIt is only useful with reification-like constraints.\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.False","page":"Sets","title":"ConstraintProgrammingExtensions.False","text":"False()\n\nA constraint that is always false. \n\nIt is only useful with reification-like constraints.\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#Scheduling-constraints","page":"Sets","title":"Scheduling constraints","text":"","category":"section"},{"location":"reference/sets/","page":"Sets","title":"Sets","text":"CumulativeResource\nCumulativeResourceWithDeadline\nNonOverlappingOrthotopes\nConditionallyNonOverlappingOrthotopes","category":"page"},{"location":"reference/sets/#ConstraintProgrammingExtensions.CumulativeResource","page":"Sets","title":"ConstraintProgrammingExtensions.CumulativeResource","text":"CumulativeResource(n_tasks::Int)\n\nEach task is given by a minimum start time (the first n_tasks variables),  a duration (the next n_tasks variables), and the resource consumption  (the following n_tasks variables). The final variable is the maximum amount of the resource available.\n\nAlso called cumulative. This version does not consider end deadlines for tasks.\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.CumulativeResourceWithDeadline","page":"Sets","title":"ConstraintProgrammingExtensions.CumulativeResourceWithDeadline","text":"CumulativeResourceWithDeadline(n_tasks::Int)\n\nEach task is given by a minimum start time (the first n_tasks variables),  a duration (the next n_tasks variables), a deadline (the following n_tasks  variables), and the resource consumption (the next n_tasks variables).  The final variable is the maximum amount of the resource available.\n\nAlso called cumulative.\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.NonOverlappingOrthotopes","page":"Sets","title":"ConstraintProgrammingExtensions.NonOverlappingOrthotopes","text":"NonOverlappingOrthotopes(n_orthotopes::Int, n_dimensions::Int)\n\nGuarantees that the n_orthotopes orthotopes do not overlap. The orthotopes  live in various dimensions: segments if n_dimensions = 1, rectangles if  n_dimensions = 2, rectangular parallelepiped if n_dimensions = 3,  hyperrectangles otherwise.\n\nThe variables are packed by orthotope: \n\nthe first n_dimensions are the origin of the orthotope\nthe next n_dimensions are the size of the orthotope in each dimension\nthe last n_dimensions are the destination of the orthotope. These variables are automatically constrained to be origin + size (unlike other modelling  layers, such as Gecode)\n\nThe set can be defined as: \n\n(o_1 s_1 d_1 o_2 s_2 d_2 dots o_mathtto s_mathtto d_mathtto) in mathbbR^3 times mathtto times mathttd \n\nAlso called diffn,  geost, nooverlap, diff2, or disjoint.\n\nExample: two 2-D rectangles\n\n[x1, y1, w1, h1, x1e, y1e, x2, y2, w2, h2, x2e, y2e] in NonOverlappingOrthotopes(2, 2)\n# Enforces the following five constraints: \n#   OR(\n#     x1 + w1 <= x2,\n#     x2 + w2 <= x1,\n#     y1 + h1 <= y2,\n#     y2 + h2 <= y1\n#   )\n#   x1e = x1 + w1\n#   y1e = y1 + h1\n#   x2e = x2 + w2\n#   y2e = y2 + h2\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.ConditionallyNonOverlappingOrthotopes","page":"Sets","title":"ConstraintProgrammingExtensions.ConditionallyNonOverlappingOrthotopes","text":"ConditionallyNonOverlappingOrthotopes(n_orthotopes::Int, n_dimensions::Int)\n\nGuarantees that the n_orthotopes orthotopes do not overlap, with a binary  variable indicating whether a given orthotope must not overlap with other  orthotopes (if 1) or if it can be ignored (if 0). The orthotopes live in  various dimensions: segments if n_dimensions = 1, rectangles if  n_dimensions = 2, rectangular parallelepiped if n_dimensions = 3,  hyperrectangles otherwise.\n\nThe variables are packed by orthotope: \n\nthe first n_dimensions are the origin of the orthotope\nthe next n_dimensions are the size of the orthotope in each dimension\nthe next n_dimensions are the destination of the orthotope. These variables are automatically constrained to be origin + size (unlike other modelling  layers, such as Gecode)\nthe last variable indicates whether the orthotope is mandatory (true) or  optional (false)\n\nThe set can be defined as: \n\n(o_1 s_1 d_1 m_1 o_2 s_2 d_2 m_2 dots o_mathtto s_mathtto d_mathtto m_mathtto) in prod_i=1^mathtto (mathbbR^3 times mathttd times 0 1) \n\nAlso called diffn,  nooverlap, or disjointconditional.\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#Sorting-constraints","page":"Sets","title":"Sorting constraints","text":"","category":"section"},{"location":"reference/sets/#Lexicographic-order","page":"Sets","title":"Lexicographic order","text":"","category":"section"},{"location":"reference/sets/","page":"Sets","title":"Sets","text":"LexicographicallyLessThan\nLexicographicallyGreaterThan\nDoublyLexicographicallyLessThan\nDoublyLexicographicallyGreaterThan","category":"page"},{"location":"reference/sets/#ConstraintProgrammingExtensions.LexicographicallyLessThan","page":"Sets","title":"ConstraintProgrammingExtensions.LexicographicallyLessThan","text":"LexicographicallyLessThan(dimension::Int)\n\nEnsures that each column of the matrix is lexicographically less than  the next column. \n\nFormally, for two columns:\n\n(x y) in mathbbR^mathttdimension times mathbbR^mathttcolumn_dim  exists j in 1 2 dots mathttcolumn_dim x_j  y_j forall i  j x_i = y_i .\n\nAlso called lex_less.\n\nThe matrix is encoded by stacking the columns, matching the behaviour of Julia's vec function.\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.LexicographicallyGreaterThan","page":"Sets","title":"ConstraintProgrammingExtensions.LexicographicallyGreaterThan","text":"LexicographicallyGreaterThan(dimension::Int)\n\nEnsures that each column of the matrix is lexicographically greater than  the next column. \n\nFormally, for two columns:\n\n(x y) in mathbbR^mathttdimension times mathbbR^mathttcolumn_dim  xists j in 1 2 dots mathttdimension x_j  y_j forall i  j x_i = y_i .\n\nAlso called lex_greater.\n\nThe matrix is encoded by stacking the columns, matching the behaviour of Julia's vec function.\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.DoublyLexicographicallyLessThan","page":"Sets","title":"ConstraintProgrammingExtensions.DoublyLexicographicallyLessThan","text":"DoublyLexicographicallyLessThan(dimension::Int)\n\nEnsures that each column of the matrix is lexicographically less than  the next column, and that each row of the matrix is lexicographically less  than the next row. \n\nAlso called lex2.\n\nThe matrix is encoded by stacking the columns, matching the behaviour of Julia's vec function.\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.DoublyLexicographicallyGreaterThan","page":"Sets","title":"ConstraintProgrammingExtensions.DoublyLexicographicallyGreaterThan","text":"DoublyLexicographicallyGreaterThan(dimension::Int)\n\nEnsures that each column of the matrix is lexicographically greater than  the next column, and that each row of the matrix is lexicographically greater  than the next row. \n\nThe matrix is encoded by stacking the columns, matching the behaviour of Julia's vec function.\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#Typical-order","page":"Sets","title":"Typical order","text":"","category":"section"},{"location":"reference/sets/","page":"Sets","title":"Sets","text":"Sort\nSortPermutation","category":"page"},{"location":"reference/sets/#ConstraintProgrammingExtensions.Sort","page":"Sets","title":"ConstraintProgrammingExtensions.Sort","text":"Sort(dimension::Int)\n\nEnsures that the first dimension elements is a sorted copy of the next dimension elements.\n\nExample\n\n[a, b, c, d] in Sort(2)\n# Enforces that:\n# - the first part is sorted: a <= b\n# - the first part corresponds to the second one:\n#     - either a = c and b = d\n#     - or a = d and b = c\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.SortPermutation","page":"Sets","title":"ConstraintProgrammingExtensions.SortPermutation","text":"SortPermutation(dimension::Int)\n\nEnsures that the first dimension elements is a sorted copy of the next dimension elements.\n\nThe last dimension elements give a permutation to get from the original array to its sorted version.\n\nExample\n\n[a, b, c, d, i, j] in SortPermutation(2)\n# Enforces that:\n# - the first part is sorted: a <= b\n# - the first part corresponds to the second one:\n#     - either a = c and b = d: in this case, i = 1 and j = 2\n#     - or a = d and b = c: in this case, i = 2 and j = 1\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#Extrema","page":"Sets","title":"Extrema","text":"","category":"section"},{"location":"reference/sets/","page":"Sets","title":"Sets","text":"MaximumAmong\nMinimumAmong\nArgumentMaximumAmong\nArgumentMinimumAmong","category":"page"},{"location":"reference/sets/#ConstraintProgrammingExtensions.MaximumAmong","page":"Sets","title":"ConstraintProgrammingExtensions.MaximumAmong","text":"MaximumAmong(dimension::Int)\n\nEnsures that the first element is the maximum value among the next  dimension elements.\n\nExample\n\n[a, b, c] in MaximumAmong(2)\n# Enforces that a == max(b, c)\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.MinimumAmong","page":"Sets","title":"ConstraintProgrammingExtensions.MinimumAmong","text":"MinimumAmong(dimension::Int)\n\nEnsures that the first element is the minimum value among the next  dimension elements.\n\nExample\n\n[a, b, c] in MinimumAmong(2)\n# Enforces that a == min(b, c)\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.ArgumentMaximumAmong","page":"Sets","title":"ConstraintProgrammingExtensions.ArgumentMaximumAmong","text":"ArgumentMaximumAmong(dimension::Int)\n\nEnsures that the first element is the index of the maximum value among the  next dimension elements.\n\nExample\n\n[a, b, c] in ArgumentMaximumAmong(2)\n# Enforces that a == argmax(b, c)\n# I.e., if b > c, a = 1, if b < c, a = 2\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#ConstraintProgrammingExtensions.ArgumentMinimumAmong","page":"Sets","title":"ConstraintProgrammingExtensions.ArgumentMinimumAmong","text":"ArgumentMinimumAmong(dimension::Int)\n\nEnsures that the first element is the index of the minimum value among the  next dimension elements.\n\nExample\n\n[a, b, c] in ArgumentMinimumAmong(2)\n# Enforces that a == argmin(b, c)\n# I.e., if b < c, a = 1, if b > c, a = 2\n\n\n\n\n\n","category":"type"},{"location":"reference/sets/#Strict-constraints","page":"Sets","title":"Strict constraints","text":"","category":"section"},{"location":"reference/sets/","page":"Sets","title":"Sets","text":"Strictly","category":"page"},{"location":"reference/sets/#ConstraintProgrammingExtensions.Strictly","page":"Sets","title":"ConstraintProgrammingExtensions.Strictly","text":"Strictly{S <: Union{LessThan{T}, GreaterThan{T}, LexicographicallyGreaterThan}}\n\nConverts an inequality set to a set with the same inequality made strict. For example, while LessThan(1) corresponds to the inequality x <= 1, Strictly(LessThan(1)) corresponds to the inequality x < 1.\n\nExample\n\nx in Strictly(LessThan(1))\n\n\n\n\n\n","category":"type"}]
}
